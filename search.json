[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to R/Bioconductor",
    "section": "",
    "text": "Preface\nThis book contains the materials for the course Introduction to R/Bioconductor, which I offer in partnership with Physalia courses. This is a 5-day course, and each chapter of this book contains the materials for one day. In details:\n\nGetting started with R data classes\nData analysis with the tidyverse\nVisualizing data with {ggplot2}\nIntroduction to Bioconductor data classes - part 1\nIntroduction to Bioconductor data classes - part 2"
  },
  {
    "objectID": "chapters/00_setup.html#software-and-required-packages",
    "href": "chapters/00_setup.html#software-and-required-packages",
    "title": "Setup",
    "section": "Software and required packages",
    "text": "Software and required packages\nTo run the code in this book, you will need to install:\n\nR (&gt;=4.2.0): go to the CRAN website, choose your OS (Windows, Linux, or macOS), and follow the installation instructions.\nRStudio Desktop: go to the RStudio website and download the installer for your OS.\n\nAfter installing R and RStudio, you will need to install some required R packages. To do that, open RStudio and execute the code below in your console:\n\n# Install BiocManager\ninstall.packages(\"BiocManager\")\n\n# Use BiocManager to install required packages\npackages &lt;- c(\n    \"tidyverse\", \"SummarizedExperiment\", \"hexbin\",\n    \"patchwork\", \"gridExtra\", \"lubridate\",\n    \"GenomicRanges\", \"Biostrings\"\n)\n\nBiocManager::install(packages)"
  },
  {
    "objectID": "chapters/00_setup.html#course-materials",
    "href": "chapters/00_setup.html#course-materials",
    "title": "Setup",
    "section": "Course materials",
    "text": "Course materials\nThroughout the course, you will use some example data sets. You will also need code handouts to use during the live coding sessions.\nTo get all the materials you will need to:\n\nNavigate to https://github.com/almeidasilvaf/r-bioc-intro\nClone the repository by clicking Code &gt; Download ZIP\nExtract the .zip file\n(Optional) Move the folder with all course materials to a directory of your choice in your machine (you don’t want to leave it in Downloads/, right?)"
  },
  {
    "objectID": "chapters/01_intro_to_R.html#goals-of-this-lesson",
    "href": "chapters/01_intro_to_R.html#goals-of-this-lesson",
    "title": "1  Getting started with R data classes",
    "section": "1.1 Goals of this lesson",
    "text": "1.1 Goals of this lesson\nThis lesson was designed to be a gentle introduction to R for biologists. Thus, we will only cover the basics of the language. An alternative name for this lesson could be “all you need to know about R to start your analyses”. At the end of this lesson, you will be able to:\n\nperform simple mathematical operations in R\ncreate and modify objects\nuse functions and look for help\ncreate vectors and understand the difference between vector types\ncreate data frames\nsubset vectors and data frames"
  },
  {
    "objectID": "chapters/01_intro_to_R.html#creating-objects",
    "href": "chapters/01_intro_to_R.html#creating-objects",
    "title": "1  Getting started with R data classes",
    "section": "1.2 Creating objects",
    "text": "1.2 Creating objects\nThe simplest use of R is to perform mathematical operations, which can be simply typed in the console:\n\n2 + 2\n\n[1] 4\n\n4 * 5\n\n[1] 20\n\n20 / 10\n\n[1] 2\n\n5 - 3\n\n[1] 2\n\n\nHowever, simple mathematical operations are not very useful. Typically, you would want to assign values to R objects. R objects can be created by using object_name + &lt;- + value. The &lt;- symbol is called the “assignment operator”, and it assigns values to objects. Example:\n\ngenome_size &lt;- 2000000\n\nNote that when you assign a value to an object, nothing happens on the screen. In the example above, we created an object named genome_size that contains the value 2000000, but the value is not printed to screen. To show the contents of an object, you must type its name and execute it. For example:\n\ngenome_size\n\n[1] 2e+06\n\n\nAlternatively, we can assign values to objects AND print them at the same time by surrounding the assignment code with parentheses. For example:\n\n(genome_size &lt;- 2000000)\n\n[1] 2e+06\n\n\n\n\n\n\n\n\nNaming objects\n\n\n\nAlthough you can give your objects whatever name you want, some general best practices include:\n\nChoose a descriptive name, but not too long.\nDo not use dots (.).\nUse nouns.\nBe consistent with your styling. Styles include snake case (e.g., phylo_tree) and camel case (e.g., phyloTree.)\n\nNote that object names cannot start with numbers.\n\n\nNow that we have an object genome_size with a value, we can use the object to perform mathematical operations. For example, let’s suppose we want to see the genome size in many thousands of base pairs (i.e., kbp, which stands for kilobase pairs):\n\ngenome_size / 1000\n\n[1] 2000\n\n\nWe can also change the value of an object by assigning a new value to it. For instance, let’s update the genome_size object with the size in kbp:\n\ngenome_size # original object\n\n[1] 2e+06\n\ngenome_size &lt;- genome_size / 1000 # modifying the object\ngenome_size\n\n[1] 2000\n\n\nAs you can see, the object genome_size now contains the value 2000."
  },
  {
    "objectID": "chapters/01_intro_to_R.html#functions-and-arguments",
    "href": "chapters/01_intro_to_R.html#functions-and-arguments",
    "title": "1  Getting started with R data classes",
    "section": "1.3 Functions and arguments",
    "text": "1.3 Functions and arguments\nFunctions are scripts that automate a particular task, and they typically have verbs in their names. They are made available to users as part of packages, and there are several R packages with specialized functions for each field. When you download and install R, it already comes with some packages installed, such as base and utils, but you can also install other packages depending on your needs.\nA function takes one or many arguments as input and returns something as output. To execute a function in R, you need to write the function name followed by the arguments inside parenthesis. For example, let’s execute the function sqrt(), which takes a numeric value as input and returns its square root:\n\nsqrt(100)\n\n[1] 10\n\n\nYou can also pass objects as input to functions. For example, let’s pass our object genome_size to the sqrt() function:\n\nsqrt(genome_size)\n\n[1] 44.72136\n\n\nTo see all the possible arguments a function takes, use the function args() with the function name as input. For example, let’s see all possible arguments for the round() function (which rounds up numbers):\n\nargs(round)\n\nfunction (x, digits = 0) \nNULL\n\n\nWe can see that the round() function can take two arguments as input: x, which is a numeric value, and digits, which indicates how many digits should be used when rounding values. Let’s try to execute the round() function with different options to digits.\n\npi &lt;- 3.14159\nround(pi)\n\n[1] 3\n\nround(pi, digits = 2)\n\n[1] 3.14\n\nround(pi, digits = 3)\n\n[1] 3.142\n\n\nFinally, if you want to learn more about what a function does and how to use it, you can type the function name preceded by a question mark. For example:\n\n?round\n\nThis will open up a help page with detailed information on what the function does, its arguments, and examples.\n\n\n\n\n\n\nExercises\n\n\n\nThe genome of the plant Arabidopsis thaliana contains 33768 genes, of which 27655 are protein-coding and 6113 encode non-coding RNAs. Calculate the percentage of coding and non-coding genes in this genome using the following steps:\n\nCreate a variable named ath_genes that stores the numeric value 33768.\nCreate 2 objects named n_coding and n_noncoding that store the numeric values 27655 and 6113, respectively.\nCreate 2 objects named perc_coding and perc_noncoding by dividing n_coding and n_noncoding by ath_genes.\nUpdate the objects by multiplying their contents by 100 (to represent in percentages, from 0 to 100) and rounding the percentages to 1 significant digit only.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Store values in objects\nath_genes &lt;- 33768\nn_coding &lt;- 27655\nn_noncoding &lt;- 6113\n\n# Get percentages\nperc_coding &lt;- n_coding / ath_genes\nperc_noncoding &lt;- n_noncoding / ath_genes\n\n# Update objects with actual percentages\nperc_coding &lt;- round(perc_coding * 100, 1)\nperc_noncoding &lt;- round(perc_noncoding * 100, 1)\n\n# Show contents of the objects\nperc_coding\n\n[1] 81.9\n\nperc_noncoding\n\n[1] 18.1"
  },
  {
    "objectID": "chapters/01_intro_to_R.html#data-structures",
    "href": "chapters/01_intro_to_R.html#data-structures",
    "title": "1  Getting started with R data classes",
    "section": "1.4 Data structures",
    "text": "1.4 Data structures\nNow, we will explore two data structures in R that we will use all the time throughout the lessons (and in our research routine): vectors and data frames.\n\n1.4.1 Vectors\nVector are the most common data structures in R, and they are used to store multiple values. There are 6 kinds of values that can be stored in a vector, but the ones we typically use are:\n\nnumeric: numbers.\ncharacter: text strings.\nlogical: either TRUE or FALSE.\n\nThe other types are integer, complex, and raw, but they are not important here.\nTo create a vector, you will use the c() function to combine values. For example:\n\n# Creating a numeric vector\ngenome_sizes &lt;- c(33768, 52872, 39756)\ngenome_sizes\n\n[1] 33768 52872 39756\n\n# Creating a character vector\nspecies &lt;- c(\"Arabidopsis\", \"soybean\", \"maize\")\nspecies\n\n[1] \"Arabidopsis\" \"soybean\"     \"maize\"      \n\n\nYou can inspect vectors with the functions:\n\nclass(): shows the class of a vector.\nlength(): shows the number of elements in a vector.\nstr(): summarizes the structure of a vector.\n\n\nclass(genome_sizes)\n\n[1] \"numeric\"\n\nlength(genome_sizes)\n\n[1] 3\n\nstr(genome_sizes)\n\n num [1:3] 33768 52872 39756\n\n\nYou can also combine two vectors:\n\nspecies1 &lt;- c(\"soybean\", \"maize\")\nspecies2 &lt;- c(\"cotton\", \"bean\")\ncombined_species &lt;- c(species1, species2)\ncombined_species\n\n[1] \"soybean\" \"maize\"   \"cotton\"  \"bean\"   \n\n\nNOTE: Vectors can only store values of the same type (i.e., character, numeric, etc). If you try to create a vector that contains values of different types, R converts them to all be the same type. This conversion of one class to another is called coercion. For example:\n\n# Creating a vector with numeric and character values\nc_vector &lt;- c(\"a\", \"b\", 1, \"d\")\nc_vector\n\n[1] \"a\" \"b\" \"1\" \"d\"\n\n\nIn the example above, R converted the numeric value 1 to a character.\n\n\n1.4.2 Data frames\nData frames is the name R uses to call tables. To create a new data frame, you will use the data.frame() function. Each column of a data frame is a vector, so you can create a data frame by passing each vector to each column. For example, let’s recreate the genome_sizes and species vectors we created in the previous section and store them in columns genome_size and species of a data frame:\n\n# Create vectors again\ngenome_sizes &lt;- c(33768, 52872, 39756)\nspecies &lt;- c(\"Arabidopsis\", \"soybean\", \"maize\")\n\n# Create a data frame with columns `genome_size` and `species`\ngenome_size_df &lt;- data.frame(\n    genome_size = genome_sizes,\n    species = species\n)\n\ngenome_size_df\n\n  genome_size     species\n1       33768 Arabidopsis\n2       52872     soybean\n3       39756       maize\n\n\nWe can also create the vectors inside the data.frame() function itself:\n\ngenome_size_df &lt;- data.frame(\n    genome_size = c(33768, 52872, 39756),\n    species = c(\"Arabidopsis\", \"soybean\", \"maize\")\n)\n\ngenome_size_df\n\n  genome_size     species\n1       33768 Arabidopsis\n2       52872     soybean\n3       39756       maize\n\n\nTo add a column to an existing data frame, you have to add $ followed by the new column name in front of the object name. For example, let’s add a column named is_model to the genome_size_df data frame that indicates whether or not a species is a model species:\n\n# Add `is_model` column\ngenome_size_df$is_model &lt;- c(TRUE, FALSE, FALSE)\ngenome_size_df\n\n  genome_size     species is_model\n1       33768 Arabidopsis     TRUE\n2       52872     soybean    FALSE\n3       39756       maize    FALSE\n\n\nFinally, to inspect a data frame, you can use the following functions:\n\ndim(): shows the dimensions of the data frame (i.e., number of rows and columns, respectively).\nnrow(): shows the number of rows in a data frame.\nncol(): shows the number of columns in a data frame.\nhead(): shows the first 6 rows of a data frame.\ntail(): shows the last 6 rows of a data frame.\nnames(): shows the column names.\nrownames(): shows the row names\nstr(): summarizes the structure of a data frame.\nsummary(): shows summary statistics for each column.\n\n\n\n\n\n\n\nExercises\n\n\n\n\nThe plants Brussels sprout, grapevine and apple belong to the families Brassicaceae, Vitaceae, and Rosaceae. Create a data frame named species_families with 2 columns named species and family representing such information.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nspecies_families &lt;- data.frame(\n    species = c(\"Brussels sprout\", \"grapevine\", \"apple\"),\n    family = c(\"Brassicaceae\", \"Vitaceae\", \"Rosaceae\")\n)\n\nspecies_families\n\n          species       family\n1 Brussels sprout Brassicaceae\n2       grapevine     Vitaceae\n3           apple     Rosaceae\n\n\n\n\n\n\nWhen you install R, it already comes with some example data sets. One of them is airquality, a data frame containing New York air quality measurements from May to September 1973. Inspect this data frame and answer the following questions:\n\nHow many rows are there?\nHow many columns are there?\nWhat are the column names?\nWhat are the classes of each column?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nstr(airquality)\n\n'data.frame':   153 obs. of  6 variables:\n $ Ozone  : int  41 36 12 18 NA 28 23 19 8 NA ...\n $ Solar.R: int  190 118 149 313 NA NA 299 99 19 194 ...\n $ Wind   : num  7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ...\n $ Temp   : int  67 72 74 62 56 66 65 59 61 69 ...\n $ Month  : int  5 5 5 5 5 5 5 5 5 5 ...\n $ Day    : int  1 2 3 4 5 6 7 8 9 10 ..."
  },
  {
    "objectID": "chapters/01_intro_to_R.html#indexing-and-subsetting",
    "href": "chapters/01_intro_to_R.html#indexing-and-subsetting",
    "title": "1  Getting started with R data classes",
    "section": "1.5 Indexing and subsetting",
    "text": "1.5 Indexing and subsetting\nHere, you will learn how to extract specific elements of vectors and data frames, which is called subsetting.\n\n1.5.1 Vectors\nTo subset vectors, you need to pass the index of the element you want to extract inside square brackets ([]). If you want to extract multiple elements, you have to pass a vector of indices inside the square brackets. For example:\n\nplants &lt;- c(\"rice\", \"maize\", \"duckweed\")\n\n# Extract 1st element\nplants[1]\n\n[1] \"rice\"\n\n# Extract 1st and 2nd element\nplants[c(1, 2)]\n\n[1] \"rice\"  \"maize\"\n\n# Extract 3rd and 2nd element (in this order)\nplants[c(3, 2)]\n\n[1] \"duckweed\" \"maize\"   \n\n\nYou can also remove a given element by adding a minus (-) symbol before the index:\n\n# Get all elements, except the 1st\nplants[-1]\n\n[1] \"maize\"    \"duckweed\"\n\n# Get all elements, except the 1st and 3rd\nplants[-c(1, 3)]\n\n[1] \"maize\"\n\n\nAnother very common way to subset vectors is by using logical vectors. When using logical vectors, TRUE and FALSE will indicate whether to extract or not extract the element. For example, let’s use logical vectors to subset the plants vector we created above:\n\nplants\n\n[1] \"rice\"     \"maize\"    \"duckweed\"\n\n# Extract 1st element, do not extract 2nd and 3rd elements\nplants[c(TRUE, FALSE, FALSE)]\n\n[1] \"rice\"\n\n# Extract 1st and 3rd elements, do not extract 2nd\nplants[c(TRUE, FALSE, TRUE)]\n\n[1] \"rice\"     \"duckweed\"\n\n\nNow, you might be thinking: using logical vectors seems complicated. Why would someone do this instead of using indices?. The answer is conditional subsetting. In R, you can use logical expressions that return TRUE or FALSE to extract elements. For example, let’s create a vector of genome sizes for fictional species and check if they more than 20,000 genes:\n\nngenes &lt;- c(52000, 35000, 18000, 17000, 22000, 11000, 13000)\n\n# Logical expression: is the element &gt;= 20000?\nngenes &gt; 20000\n\n[1]  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE\n\n\nYou can see that the logical expression returns a vector of TRUEs and FALSEs. Since TRUE means extract and FALSE means do not extract when subsetting, we can use logical expressions to subset vectors as follows:\n\n# Extract elements with &gt;=20000 genes\nngenes[ngenes &gt; 20000]\n\n[1] 52000 35000 22000\n\n\nYou can combine multiple tests in logical expressions using & (which means AND, both conditions are true) and | (which means OR, at least one of the conditions is true).\n\n# Extract elements with number of genes between 20000 and 40000\nngenes[ngenes &gt; 20000 & ngenes &lt; 40000]\n\n[1] 35000 22000\n\n# Extract elements with 13000 or 11000 genes\nngenes[ngenes == 13000 | ngenes == 11000]\n\n[1] 11000 13000\n\n\nYou can also subset a vector based on the presence of some pre-defined elements using the %in% operator. For example:\n\nanimals &lt;- c(\"dog\", \"cat\", \"rat\", \"pig\", \"horse\")\n\nanimals[animals %in% c(\"cat\", \"dog\")]\n\n[1] \"dog\" \"cat\"\n\n\n\n\n1.5.2 Data frames\nSubsetting data frames in very similar to subsetting vectors. The only difference is that data frames have 2 dimensions (rows and columns), while vectors have only 1 dimension. Thus, when you subset a data frame, you have to specify which dimension you want to use. For instance, if you execute vec[2], you will extract the 2nd element of the vector vec. However, if you pass the index 2 to a data frame, you can mean either the 2nd row or the second column. To subset data frames, you will use commas (,) inside square brackets to distinguish rows (which come before the comma) from columns (which come after the comma. For example:\n\n# See the first 6 rows the `airquality` data frame\nhead(airquality)\n\n  Ozone Solar.R Wind Temp Month Day\n1    41     190  7.4   67     5   1\n2    36     118  8.0   72     5   2\n3    12     149 12.6   74     5   3\n4    18     313 11.5   62     5   4\n5    NA      NA 14.3   56     5   5\n6    28      NA 14.9   66     5   6\n\n# Extract the element in row 1, column 2\nairquality[1, 2]\n\n[1] 190\n\n# Extract rows 1 to 5, column 1 - note: `1:5` is the same as `c(1, 2, 3, 4, 5)`\nairquality[1:5, 1]\n\n[1] 41 36 12 18 NA\n\n\nTo extract all rows or all columns, leave the corresponding field empty:\n\n# Extract row 2, all columns\nairquality[2, ]\n\n  Ozone Solar.R Wind Temp Month Day\n2    36     118    8   72     5   2\n\n# Extract column 2, all rows\nairquality[, 2]\n\n  [1] 190 118 149 313  NA  NA 299  99  19 194  NA 256 290 274  65 334 307  78\n [19] 322  44   8 320  25  92  66 266  NA  13 252 223 279 286 287 242 186 220\n [37] 264 127 273 291 323 259 250 148 332 322 191 284  37 120 137 150  59  91\n [55] 250 135 127  47  98  31 138 269 248 236 101 175 314 276 267 272 175 139\n [73] 264 175 291  48 260 274 285 187 220   7 258 295 294 223  81  82 213 275\n [91] 253 254  83  24  77  NA  NA  NA 255 229 207 222 137 192 273 157  64  71\n[109]  51 115 244 190 259  36 255 212 238 215 153 203 225 237 188 167 197 183\n[127] 189  95  92 252 220 230 259 236 259 238  24 112 237 224  27 238 201 238\n[145]  14 139  49  20 193 145 191 131 223\n\n\nYou can also subset columns based on their names:\n\nairquality$Month\n\n  [1] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6\n [38] 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7\n [75] 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n[112] 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9\n[149] 9 9 9 9 9\n\nairquality[, \"Month\"] # same thing\n\n  [1] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6\n [38] 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7\n [75] 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n[112] 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9\n[149] 9 9 9 9 9\n\n\nAs we did with vectors, we can subset the data frame using logical expressions:\n\n# Extract rows for which column \"Month\" is equal to 5\nairquality[airquality$Month == 5, ]\n\n   Ozone Solar.R Wind Temp Month Day\n1     41     190  7.4   67     5   1\n2     36     118  8.0   72     5   2\n3     12     149 12.6   74     5   3\n4     18     313 11.5   62     5   4\n5     NA      NA 14.3   56     5   5\n6     28      NA 14.9   66     5   6\n7     23     299  8.6   65     5   7\n8     19      99 13.8   59     5   8\n9      8      19 20.1   61     5   9\n10    NA     194  8.6   69     5  10\n11     7      NA  6.9   74     5  11\n12    16     256  9.7   69     5  12\n13    11     290  9.2   66     5  13\n14    14     274 10.9   68     5  14\n15    18      65 13.2   58     5  15\n16    14     334 11.5   64     5  16\n17    34     307 12.0   66     5  17\n18     6      78 18.4   57     5  18\n19    30     322 11.5   68     5  19\n20    11      44  9.7   62     5  20\n21     1       8  9.7   59     5  21\n22    11     320 16.6   73     5  22\n23     4      25  9.7   61     5  23\n24    32      92 12.0   61     5  24\n25    NA      66 16.6   57     5  25\n26    NA     266 14.9   58     5  26\n27    NA      NA  8.0   57     5  27\n28    23      13 12.0   67     5  28\n29    45     252 14.9   81     5  29\n30   115     223  5.7   79     5  30\n31    37     279  7.4   76     5  31\n\n# Extract rows with \"Temp\" &gt;90, then show only columns \"Month\" and \"Day\"\nairquality[airquality$Temp &gt; 90, c(\"Month\", \"Day\")]\n\n    Month Day\n42      6  11\n43      6  12\n69      7   8\n70      7   9\n75      7  14\n102     8  10\n120     8  28\n121     8  29\n122     8  30\n123     8  31\n124     9   1\n125     9   2\n126     9   3\n127     9   4\n\n\n\n\n\n\n\n\nExercises\n\n\n\nSubset the airquality data set to answer the following questions:\n\nHow many days (rows) observations have ozone levels &gt;40 ppb?\nHow many days have wind speed between 10 and 15 mph?\nWhat are the minimum and maximum temperature?\nHow many days have solar radiation &lt;100 Langleys?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Q1: Ozone levels &gt;40 ppb\nnrow(airquality[airquality$Ozone &gt; 40, ])\n\n[1] 82\n\n# Q2: Wind speed between 10 and 15 mph\nnrow(airquality[airquality$Wind &gt;= 10 & airquality$Wind &lt;=15, ])\n\n[1] 62\n\n# Q3: Minimum and maximum temperature\nsummary(airquality)\n\n     Ozone           Solar.R           Wind             Temp      \n Min.   :  1.00   Min.   :  7.0   Min.   : 1.700   Min.   :56.00  \n 1st Qu.: 18.00   1st Qu.:115.8   1st Qu.: 7.400   1st Qu.:72.00  \n Median : 31.50   Median :205.0   Median : 9.700   Median :79.00  \n Mean   : 42.13   Mean   :185.9   Mean   : 9.958   Mean   :77.88  \n 3rd Qu.: 63.25   3rd Qu.:258.8   3rd Qu.:11.500   3rd Qu.:85.00  \n Max.   :168.00   Max.   :334.0   Max.   :20.700   Max.   :97.00  \n NA's   :37       NA's   :7                                       \n     Month            Day      \n Min.   :5.000   Min.   : 1.0  \n 1st Qu.:6.000   1st Qu.: 8.0  \n Median :7.000   Median :16.0  \n Mean   :6.993   Mean   :15.8  \n 3rd Qu.:8.000   3rd Qu.:23.0  \n Max.   :9.000   Max.   :31.0  \n                               \n\n# Q4: Solar radiation &lt;100 Langleys\nnrow(airquality[airquality$Solar.R &lt; 100, ])\n\n[1] 41"
  },
  {
    "objectID": "chapters/02_tidyverse.html#goals-of-this-lesson",
    "href": "chapters/02_tidyverse.html#goals-of-this-lesson",
    "title": "2  Data processing with the tidyverse",
    "section": "2.1 Goals of this lesson",
    "text": "2.1 Goals of this lesson\nAt the end of this lesson, you will be able to:\n\nread tabular data from .csv/.tsv/.txt/ files\nfilter your data set to select particular rows and columns\nadd columns\nsummarize data\ncombine different data frames\nreshape data from long to wide, and back"
  },
  {
    "objectID": "chapters/02_tidyverse.html#the-readr-package-reading-files",
    "href": "chapters/02_tidyverse.html#the-readr-package-reading-files",
    "title": "2  Data processing with the tidyverse",
    "section": "2.2 The readr package: reading files",
    "text": "2.2 The readr package: reading files\nThe data we will use in this lesson are in data/rnaseq.csv in the GitHub repo associated with this course. This is a comma-separated file, which means it contains a table in which columns are separated by commas. To read .csv files, we will use the function read_csv() from the readr package.\n\n# Read csv file\nrna &lt;- read_csv(here(\"data\", \"rnaseq.csv\"))\n\n# Inspect the data\nhead(rna)\n\n# A tibble: 6 × 19\n  gene    sample   expression organism   age sex   infection strain  time tissue\n  &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n1 Asl     GSM2545…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n2 Apod    GSM2545…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n3 Cyp2d22 GSM2545…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n4 Klk6    GSM2545…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n5 Fcrls   GSM2545…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n6 Slc2a4  GSM2545…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nNotice that the class of the data is now referred to as a “tibble”.\nTibbles tweak some of the behaviors of the data frame objects we introduced in the previously. The data structure is very similar to a data frame. For our purposes the only differences are that:\n\nIt displays the data type of each column under its name. Note that &lt;dbl&gt; is a data type defined to hold numeric values with decimal points.\nIt only prints the first few rows of data and only as many columns as fit on one screen."
  },
  {
    "objectID": "chapters/02_tidyverse.html#the-dplyr-package-filtering-extending-and-summarizing-data",
    "href": "chapters/02_tidyverse.html#the-dplyr-package-filtering-extending-and-summarizing-data",
    "title": "2  Data processing with the tidyverse",
    "section": "2.3 The dplyr package: filtering, extending, and summarizing data",
    "text": "2.3 The dplyr package: filtering, extending, and summarizing data\nThe dplyr is one of the most main packages of the tidyverse, and it can be used to perform all sorts of day-to-day data processing. Here, we are going to learn some of the most common dplyr functions:\n\nselect(): subset columns\nfilter(): subset rows on conditions\nmutate(): create new columns by using information from other columns\ngroup_by() and summarise(): create summary statistics on grouped data\narrange(): sort results\ncount(): count discrete values\n\n\n2.3.1 Selecting columns and filtering rows\nTo select columns of a data frame, use select(). The first argument to this function is the data frame (rna), and the subsequent arguments are the columns to keep.\n\nselect(rna, gene, sample, tissue, expression)\n\n# A tibble: 32,428 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336 Cerebellum       1170\n 2 Apod    GSM2545336 Cerebellum      36194\n 3 Cyp2d22 GSM2545336 Cerebellum       4060\n 4 Klk6    GSM2545336 Cerebellum        287\n 5 Fcrls   GSM2545336 Cerebellum         85\n 6 Slc2a4  GSM2545336 Cerebellum        782\n 7 Exd2    GSM2545336 Cerebellum       1619\n 8 Gjc2    GSM2545336 Cerebellum        288\n 9 Plp1    GSM2545336 Cerebellum      43217\n10 Gnb4    GSM2545336 Cerebellum       1071\n# ℹ 32,418 more rows\n\n\nTo select all columns except certain ones, put a “-” in front of the variable to exclude it. For example, to select all columns but tissue and organism, you’d use:\n\nselect(rna, -tissue, -organism)\n\n# A tibble: 32,428 × 17\n   gene    sample   expression   age sex   infection strain  time mouse ENTREZID\n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Asl     GSM2545…       1170     8 Fema… Influenz… C57BL…     8    14   109900\n 2 Apod    GSM2545…      36194     8 Fema… Influenz… C57BL…     8    14    11815\n 3 Cyp2d22 GSM2545…       4060     8 Fema… Influenz… C57BL…     8    14    56448\n 4 Klk6    GSM2545…        287     8 Fema… Influenz… C57BL…     8    14    19144\n 5 Fcrls   GSM2545…         85     8 Fema… Influenz… C57BL…     8    14    80891\n 6 Slc2a4  GSM2545…        782     8 Fema… Influenz… C57BL…     8    14    20528\n 7 Exd2    GSM2545…       1619     8 Fema… Influenz… C57BL…     8    14    97827\n 8 Gjc2    GSM2545…        288     8 Fema… Influenz… C57BL…     8    14   118454\n 9 Plp1    GSM2545…      43217     8 Fema… Influenz… C57BL…     8    14    18823\n10 Gnb4    GSM2545…       1071     8 Fema… Influenz… C57BL…     8    14    14696\n# ℹ 32,418 more rows\n# ℹ 7 more variables: product &lt;chr&gt;, ensembl_gene_id &lt;chr&gt;,\n#   external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;, gene_biotype &lt;chr&gt;,\n#   phenotype_description &lt;chr&gt;, hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nTo choose rows based on specific criteria, use filter():\n\nfilter(rna, sex == \"Male\")\n\n# A tibble: 14,740 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…        626 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 2 Apod    GSM254…      13021 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 3 Cyp2d22 GSM254…       2171 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 4 Klk6    GSM254…        448 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 5 Fcrls   GSM254…        180 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 6 Slc2a4  GSM254…        313 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 7 Exd2    GSM254…       2366 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 8 Gjc2    GSM254…        310 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 9 Plp1    GSM254…      53126 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n10 Gnb4    GSM254…       1355 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n# ℹ 14,730 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\nfilter(rna, sex == \"Male\" & infection == \"NonInfected\")\n\n# A tibble: 4,422 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…        535 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 2 Apod    GSM254…      13668 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 3 Cyp2d22 GSM254…       2008 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 4 Klk6    GSM254…       1101 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 5 Fcrls   GSM254…        375 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 6 Slc2a4  GSM254…        249 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 7 Exd2    GSM254…       3126 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 8 Gjc2    GSM254…        791 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 9 Plp1    GSM254…      98658 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n10 Gnb4    GSM254…       2437 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n# ℹ 4,412 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nNow, let’s imagine we are interested in the human homologs of the mouse genes analysed in this dataset. This information can be found in the last column of the rna tibble, named hsapiens_homolog_associated_gene_name. To visualise it easily, we will create a new table containing just the 2 columns gene and hsapiens_homolog_associated_gene_name.\n\ngenes &lt;- select(rna, gene, hsapiens_homolog_associated_gene_name)\ngenes\n\n# A tibble: 32,428 × 2\n   gene    hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;   &lt;chr&gt;                                \n 1 Asl     ASL                                  \n 2 Apod    APOD                                 \n 3 Cyp2d22 CYP2D6                               \n 4 Klk6    KLK6                                 \n 5 Fcrls   FCRL2                                \n 6 Slc2a4  SLC2A4                               \n 7 Exd2    EXD2                                 \n 8 Gjc2    GJC2                                 \n 9 Plp1    PLP1                                 \n10 Gnb4    GNB4                                 \n# ℹ 32,418 more rows\n\n\nA very nice thing about tidyverse verbs (functions) is that they can be executed one after the other by using the pipe operator (|&gt; or %&gt;%). In practice, that means you don’t have to create intermediate objects for complicated subsetting operations that involve multiple steps. The pipe operator is often read as and then in the sense that you apply a function A and then you pass the output to function B, and then you pass the output to function C, and so on and so forth. For example:\n\n1rna |&gt;\n2    filter(sex == \"Male\") |&gt;\n3    select(gene, sample, tissue, expression)\n\n\n1\n\nTake the object rna, and then\n\n2\n\nfilter it to keep only rows that have “Male” in the column sex, and then\n\n3\n\nselect the columns gene, sample, tissue, expression\n\n\n\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\n\n\n\n\n\n\nPractice\n\n\n\n\nUsing pipes, subset the rna tibble to keep observations that match the following criteria:\n\n\nFemale mice\nTime point 0\nExpression higher than 50000\nThen, select the columns gene, sample, time, expression, and age.\n\n\nFilter rna to keep observations for infected samples, then count the number of rows. Hint: use the unique() function to see all the unique observations in a column, and the nrow() function the get the number of rows in a data frame/tibble.\nDo the same as above, but now keep only non-infected samples.\n\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Q1\nrna |&gt;\n  filter(\n      sex == \"Female\",\n      time == 0,\n      expression &gt; 50000\n  ) |&gt;\n  select(gene, sample, time, expression, age)\n\n# A tibble: 9 × 5\n  gene   sample      time expression   age\n  &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n1 Plp1   GSM2545337     0     101241     8\n2 Atp1b1 GSM2545337     0      53260     8\n3 Plp1   GSM2545338     0      96534     8\n4 Atp1b1 GSM2545338     0      50614     8\n5 Plp1   GSM2545348     0     102790     8\n6 Atp1b1 GSM2545348     0      59544     8\n7 Plp1   GSM2545353     0      71237     8\n8 Glul   GSM2545353     0      52451     8\n9 Atp1b1 GSM2545353     0      61451     8\n\n# Q2\nrna |&gt; \n    filter(infection == \"InfluenzaA\") |&gt;\n    nrow()\n\n[1] 22110\n\n# Q3\nrna |&gt;\n    filter(infection == \"NonInfected\") |&gt;\n    nrow()\n\n[1] 10318\n\n\n\n\n\n\n\n\n\n2.3.2 Adding new columns\nFrequently you’ll want to create new columns based on the values of existing columns, for example to do unit conversions, or to find the ratio of values in two columns. For this, we’ll use mutate().\nFor example, the column time contains the time in days. Let’s create a new column named time_hours that contains the time in hours.\n\nrna |&gt;\n    mutate(time_hours = time * 24) |&gt;\n    select(time, time_hours)\n\n# A tibble: 32,428 × 2\n    time time_hours\n   &lt;dbl&gt;      &lt;dbl&gt;\n 1     8        192\n 2     8        192\n 3     8        192\n 4     8        192\n 5     8        192\n 6     8        192\n 7     8        192\n 8     8        192\n 9     8        192\n10     8        192\n# ℹ 32,418 more rows\n\n\nYou can also create a second new column based on the first new column within the same call of mutate():\n\nrna |&gt;\n    mutate(\n        time_hours = time * 24,\n        time_minutes = time_hours * 60\n    ) |&gt;\n    select(time, time_hours, time_minutes)\n\n# A tibble: 32,428 × 3\n    time time_hours time_minutes\n   &lt;dbl&gt;      &lt;dbl&gt;        &lt;dbl&gt;\n 1     8        192        11520\n 2     8        192        11520\n 3     8        192        11520\n 4     8        192        11520\n 5     8        192        11520\n 6     8        192        11520\n 7     8        192        11520\n 8     8        192        11520\n 9     8        192        11520\n10     8        192        11520\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\nPractice\n\n\n\nCreate a new data frame from the rna data that meets the following criteria: contains only the gene, chromosome_name, phenotype_description, sample, and expression columns. The expression values should be log-transformed. This data frame must only contain genes located on sex chromosomes, associated with a phenotype_description, and with a log expression higher than 5.\nHint: think about how the commands should be ordered to produce this data frame!\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\nrna |&gt;\n  mutate(expression = log(expression)) |&gt;\n  select(gene, chromosome_name, phenotype_description, sample, expression) |&gt;\n  filter(chromosome_name == \"X\" | chromosome_name == \"Y\") |&gt;\n  filter(!is.na(phenotype_description)) |&gt;\n  filter(expression &gt; 5)\n\n# A tibble: 649 × 5\n   gene   chromosome_name phenotype_description                sample expression\n   &lt;chr&gt;  &lt;chr&gt;           &lt;chr&gt;                                &lt;chr&gt;       &lt;dbl&gt;\n 1 Plp1   X               abnormal CNS glial cell morphology   GSM25…      10.7 \n 2 Slc7a3 X               decreased body length                GSM25…       5.46\n 3 Plxnb3 X               abnormal coat appearance             GSM25…       6.58\n 4 Rbm3   X               abnormal liver morphology            GSM25…       9.32\n 5 Cfp    X               abnormal cardiovascular system phys… GSM25…       6.18\n 6 Ebp    X               abnormal embryonic erythrocyte morp… GSM25…       6.68\n 7 Cd99l2 X               abnormal cellular extravasation      GSM25…       8.04\n 8 Piga   X               abnormal brain development           GSM25…       6.06\n 9 Pim2   X               decreased T cell proliferation       GSM25…       7.11\n10 Itm2a  X               no abnormal phenotype detected       GSM25…       7.48\n# ℹ 639 more rows\n\n\n\n\n\n\n\n\n\n2.3.3 Summarizing grouped data\nMany data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results. dplyr makes this very easy through the use of the group_by() function.\n\nrna %&gt;%\n  group_by(gene)\n\n# A tibble: 32,428 × 19\n# Groups:   gene [1,474]\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThe group_by() function doesn’t perform any data processing, it groups the data into subsets: in the example above, our initial tibble of 32428 observations is split into 1474 groups based on the gene variable.\nOnce the data has been grouped, subsequent operations will be applied on each group independently by using the summarise() function. For example, to compute the mean expression by gene, you’d do:\n\nrna |&gt;\n    group_by(gene) |&gt;\n    summarise(mean_expression = mean(expression))\n\n# A tibble: 1,474 × 2\n   gene     mean_expression\n   &lt;chr&gt;              &lt;dbl&gt;\n 1 AI504432         1053.  \n 2 AW046200          131.  \n 3 AW551984          295.  \n 4 Aamp             4751.  \n 5 Abca12              4.55\n 6 Abcc8            2498.  \n 7 Abhd14a           525.  \n 8 Abi2             4909.  \n 9 Abi3bp           1002.  \n10 Abl2             2124.  \n# ℹ 1,464 more rows\n\n\nWe could also calculate the mean expression levels of all genes in each sample:\n\nrna |&gt;\n  group_by(sample) |&gt;\n  summarise(mean_expression = mean(expression))\n\n# A tibble: 22 × 2\n   sample     mean_expression\n   &lt;chr&gt;                &lt;dbl&gt;\n 1 GSM2545336           2062.\n 2 GSM2545337           1766.\n 3 GSM2545338           1668.\n 4 GSM2545339           1696.\n 5 GSM2545340           1682.\n 6 GSM2545341           1638.\n 7 GSM2545342           1594.\n 8 GSM2545343           2107.\n 9 GSM2545344           1712.\n10 GSM2545345           1700.\n# ℹ 12 more rows\n\n\nBut we can can also group by multiple columns:\n\nrna |&gt;\n  group_by(gene, infection, time) |&gt;\n  summarise(mean_expression = mean(expression))\n\n# A tibble: 4,422 × 4\n# Groups:   gene, infection [2,948]\n   gene     infection    time mean_expression\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;           &lt;dbl&gt;\n 1 AI504432 InfluenzaA      4           1104.\n 2 AI504432 InfluenzaA      8           1014 \n 3 AI504432 NonInfected     0           1034.\n 4 AW046200 InfluenzaA      4            152.\n 5 AW046200 InfluenzaA      8             81 \n 6 AW046200 NonInfected     0            155.\n 7 AW551984 InfluenzaA      4            302.\n 8 AW551984 InfluenzaA      8            342.\n 9 AW551984 NonInfected     0            238 \n10 Aamp     InfluenzaA      4           4870 \n# ℹ 4,412 more rows\n\n\n\n\n\n\n\n\nPractice\n\n\n\n\nCalculate the mean and median expression of all genes.\nCalculate the mean expression level of gene “Dok3” by timepoints.\n\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Q1\nrna |&gt;\n    group_by(gene) |&gt;\n    summarise(\n        mean_exp = mean(expression),\n        median_exp = median(expression)\n    )\n\n# A tibble: 1,474 × 3\n   gene     mean_exp median_exp\n   &lt;chr&gt;       &lt;dbl&gt;      &lt;dbl&gt;\n 1 AI504432  1053.        1008 \n 2 AW046200   131.         130.\n 3 AW551984   295.         273 \n 4 Aamp      4751.        4716.\n 5 Abca12       4.55         5 \n 6 Abcc8     2498.        2367 \n 7 Abhd14a    525.         503 \n 8 Abi2      4909.        4820.\n 9 Abi3bp    1002.        1008.\n10 Abl2      2124.        2134.\n# ℹ 1,464 more rows\n\n# Q2\nrna |&gt;\n  filter(gene == \"Dok3\") |&gt;\n  group_by(time) |&gt;\n  summarise(mean = mean(expression))\n\n# A tibble: 3 × 2\n   time  mean\n  &lt;dbl&gt; &lt;dbl&gt;\n1     0  169 \n2     4  156.\n3     8   61 \n\n\n\n\n\n\n\n\n\n2.3.4 Counting observations per group\nWhen working with data, we often want to know the number of observations found for each factor or combination of factors. For this task, dplyr provides count(). For example, if we wanted to count the number of rows of data for each infected and non-infected samples, we would do:\n\nrna |&gt;\n    count(infection)\n\n# A tibble: 2 × 2\n  infection       n\n  &lt;chr&gt;       &lt;int&gt;\n1 InfluenzaA  22110\n2 NonInfected 10318\n\n\nIf we wanted to count a combination of factors, such as infection and time, we would specify the first and the second factor as the arguments of count():\n\nrna |&gt;\n    count(infection, time)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\nIt is sometimes useful to sort the result to facilitate the comparisons. We can use arrange() to sort the table. For instance, we might want to arrange the table above by time:\n\n# Ascending order\nrna |&gt;\n  count(infection, time) |&gt;\n  arrange(time)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 NonInfected     0 10318\n2 InfluenzaA      4 11792\n3 InfluenzaA      8 10318\n\n# Descending order\nrna |&gt;\n  count(infection, time) |&gt;\n  arrange(-time)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      8 10318\n2 InfluenzaA      4 11792\n3 NonInfected     0 10318\n\n\n\n\n\n\n\n\nPractice\n\n\n\n\nHow many genes were analyzed in each sample?\nUse group_by() and summarise() to evaluate the sequencing depth (the sum of all counts) in each sample. Which sample has the highest sequencing depth?\nPick one sample and evaluate the number of genes by biotype.\nIdentify genes associated with the “abnormal DNA methylation” phenotype description, and calculate their mean expression (in log) at time 0, time 4 and time 8.\n\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Q1\nrna |&gt;\n  count(sample)\n\n# A tibble: 22 × 2\n   sample         n\n   &lt;chr&gt;      &lt;int&gt;\n 1 GSM2545336  1474\n 2 GSM2545337  1474\n 3 GSM2545338  1474\n 4 GSM2545339  1474\n 5 GSM2545340  1474\n 6 GSM2545341  1474\n 7 GSM2545342  1474\n 8 GSM2545343  1474\n 9 GSM2545344  1474\n10 GSM2545345  1474\n# ℹ 12 more rows\n\n# Q2\nrna |&gt;\n  group_by(sample) |&gt;\n  summarise(seq_depth = sum(expression)) |&gt;\n  arrange(-seq_depth)\n\n# A tibble: 22 × 2\n   sample     seq_depth\n   &lt;chr&gt;          &lt;dbl&gt;\n 1 GSM2545350   3255566\n 2 GSM2545352   3216163\n 3 GSM2545343   3105652\n 4 GSM2545336   3039671\n 5 GSM2545380   3036098\n 6 GSM2545353   2953249\n 7 GSM2545348   2913678\n 8 GSM2545362   2913517\n 9 GSM2545351   2782464\n10 GSM2545349   2758006\n# ℹ 12 more rows\n\n# Q3\nrna |&gt;\n  filter(sample == \"GSM2545336\") |&gt;\n  count(gene_biotype) |&gt;\n  arrange(-n)\n\n# A tibble: 13 × 2\n   gene_biotype                           n\n   &lt;chr&gt;                              &lt;int&gt;\n 1 protein_coding                      1321\n 2 lncRNA                                69\n 3 processed_pseudogene                  59\n 4 miRNA                                  7\n 5 snoRNA                                 5\n 6 TEC                                    4\n 7 polymorphic_pseudogene                 2\n 8 unprocessed_pseudogene                 2\n 9 IG_C_gene                              1\n10 scaRNA                                 1\n11 transcribed_processed_pseudogene       1\n12 transcribed_unitary_pseudogene         1\n13 transcribed_unprocessed_pseudogene     1\n\n# Q4\nrna |&gt;\n  filter(phenotype_description == \"abnormal DNA methylation\") |&gt;\n  group_by(gene, time) |&gt;\n  summarise(mean_expression = mean(log(expression))) |&gt;\n  arrange()\n\n# A tibble: 6 × 3\n# Groups:   gene [2]\n  gene   time mean_expression\n  &lt;chr&gt; &lt;dbl&gt;           &lt;dbl&gt;\n1 Xist      0            6.95\n2 Xist      4            6.34\n3 Xist      8            7.13\n4 Zdbf2     0            6.27\n5 Zdbf2     4            6.27\n6 Zdbf2     8            6.19\n\n\n\n\n\n\n\n\n\n2.3.5 Joining tables\nIn many real-life situations, data are spread across multiple tables. A common example in transcriptomics is to have gene expression in one table, and functional annotation for each gene in another table. In these cases, one may want to combine the two tables based on a column in common.\nJoining tables can be done with the dplyr functions inner_join(), full_join(), left_join(), and right_join(), each of which are exemplified in the figure below:\n\n\n\ndplyr joins\n\n\nTo demonstrate that, let’s first create a data frame with the mean expression of the genes Asl, Apod, and Klk6.\n\n# Mean expression of the genes `Asl`, `Apod`, and Klk6\nmean_exp &lt;- rna |&gt;\n    filter(gene %in% c(\"Asl\", \"Apod\", \"Klk6\")) |&gt;\n    group_by(gene) |&gt;\n    summarise(mean_exp = mean(expression))\n\nNext, we will load a table with genes and their descriptions, available in data/gene_descriptions.csv.\n\n# Read data\ndescriptions &lt;- read_csv(here(\"data\", \"gene_descriptions.csv\"))\n\n# Inspect data\nhead(descriptions)\n\n# A tibble: 6 × 2\n  gene    gene_description                                                      \n  &lt;chr&gt;   &lt;chr&gt;                                                                 \n1 Cyp2d22 cytochrome P450, family 2, subfamily d, polypeptide 22 [Source:MGI Sy…\n2 Klk6    kallikrein related-peptidase 6 [Source:MGI Symbol;Acc:MGI:1343166]    \n3 Fcrls   Fc receptor-like S, scavenger receptor [Source:MGI Symbol;Acc:MGI:193…\n4 Plp1    proteolipid protein (myelin) 1 [Source:MGI Symbol;Acc:MGI:97623]      \n5 Exd2    exonuclease 3'-5' domain containing 2 [Source:MGI Symbol;Acc:MGI:1922…\n6 Apod    apolipoprotein D [Source:MGI Symbol;Acc:MGI:88056]                    \n\n\nNow, we will combine the two tables so that we have the mean expression for each gene + gene descriptions in a single table. To combine the two tables while keeping only genes present in the column gene of both tables, we will use the function inner_join().\n\ninner_join(mean_exp, descriptions)\n\n# A tibble: 3 × 3\n  gene  mean_exp gene_description                                               \n  &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;                                                          \n1 Apod    18968. apolipoprotein D [Source:MGI Symbol;Acc:MGI:88056]             \n2 Asl       708. argininosuccinate lyase [Source:MGI Symbol;Acc:MGI:88084]      \n3 Klk6      554. kallikrein related-peptidase 6 [Source:MGI Symbol;Acc:MGI:1343…\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nJoin the tables mean_exp and descriptions using the function full_join(). How does the output change?\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\nfull_join(mean_exp, descriptions)\n\n# A tibble: 10 × 3\n   gene    mean_exp gene_description                                            \n   &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;                                                       \n 1 Apod      18968. apolipoprotein D [Source:MGI Symbol;Acc:MGI:88056]          \n 2 Asl         708. argininosuccinate lyase [Source:MGI Symbol;Acc:MGI:88084]   \n 3 Klk6        554. kallikrein related-peptidase 6 [Source:MGI Symbol;Acc:MGI:1…\n 4 Cyp2d22      NA  cytochrome P450, family 2, subfamily d, polypeptide 22 [Sou…\n 5 Fcrls        NA  Fc receptor-like S, scavenger receptor [Source:MGI Symbol;A…\n 6 Plp1         NA  proteolipid protein (myelin) 1 [Source:MGI Symbol;Acc:MGI:9…\n 7 Exd2         NA  exonuclease 3'-5' domain containing 2 [Source:MGI Symbol;Ac…\n 8 Gnb4         NA  guanine nucleotide binding protein (G protein), beta 4 [Sou…\n 9 Slc2a4       NA  solute carrier family 2 (facilitated glucose transporter), …\n10 Gjc2         NA  gap junction protein, gamma 2 [Source:MGI Symbol;Acc:MGI:21…"
  },
  {
    "objectID": "chapters/02_tidyverse.html#the-tidyr-package-from-long-to-wide-and-vice-versa",
    "href": "chapters/02_tidyverse.html#the-tidyr-package-from-long-to-wide-and-vice-versa",
    "title": "2  Data processing with the tidyverse",
    "section": "2.4 The tidyr package: from long to wide, and vice versa",
    "text": "2.4 The tidyr package: from long to wide, and vice versa\nIn the rna tibble, the rows contain expression values (the unit) that are associated with a combination of 2 other variables: gene and sample.\nAll the other columns correspond to variables describing either the sample (organism, age, sex, …) or the gene (gene_biotype, ENTREZ_ID, product, …). The variables that don’t change with genes or with samples will have the same value in all the rows.\n\nrna |&gt;\n  arrange(gene)\n\n# A tibble: 32,428 × 19\n   gene     sample expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 AI504432 GSM25…       1230 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 AI504432 GSM25…       1085 Mus mus…     8 Fema… NonInfec… C57BL…     0 Cereb…\n 3 AI504432 GSM25…        969 Mus mus…     8 Fema… NonInfec… C57BL…     0 Cereb…\n 4 AI504432 GSM25…       1284 Mus mus…     8 Fema… Influenz… C57BL…     4 Cereb…\n 5 AI504432 GSM25…        966 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 6 AI504432 GSM25…        918 Mus mus…     8 Male  Influenz… C57BL…     8 Cereb…\n 7 AI504432 GSM25…        985 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 AI504432 GSM25…        972 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 9 AI504432 GSM25…       1000 Mus mus…     8 Fema… Influenz… C57BL…     4 Cereb…\n10 AI504432 GSM25…        816 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThis structure is called a long-format, as one column contains all the values, and other column(s) list(s) the context of the value.\nIn certain cases, the long-format is not really “human-readable”, and another format, a wide-format is preferred, as a more compact way of representing the data. This is typically the case with gene expression values that scientists are used to look as matrices, were rows represent genes and columns represent samples.\nIn this format, it would therefore become straightforward to explore the relationship between the gene expression levels within, and between, the samples.\n\n\n# A tibble: 1,474 × 23\n   gene    GSM2545336 GSM2545337 GSM2545338 GSM2545339 GSM2545340 GSM2545341\n   &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n 1 Asl           1170        361        400        586        626        988\n 2 Apod         36194      10347       9173      10620      13021      29594\n 3 Cyp2d22       4060       1616       1603       1901       2171       3349\n 4 Klk6           287        629        641        578        448        195\n 5 Fcrls           85        233        244        237        180         38\n 6 Slc2a4         782        231        248        265        313        786\n 7 Exd2          1619       2288       2235       2513       2366       1359\n 8 Gjc2           288        595        568        551        310        146\n 9 Plp1         43217     101241      96534      58354      53126      27173\n10 Gnb4          1071       1791       1867       1430       1355        798\n# ℹ 1,464 more rows\n# ℹ 16 more variables: GSM2545342 &lt;dbl&gt;, GSM2545343 &lt;dbl&gt;, GSM2545344 &lt;dbl&gt;,\n#   GSM2545345 &lt;dbl&gt;, GSM2545346 &lt;dbl&gt;, GSM2545347 &lt;dbl&gt;, GSM2545348 &lt;dbl&gt;,\n#   GSM2545349 &lt;dbl&gt;, GSM2545350 &lt;dbl&gt;, GSM2545351 &lt;dbl&gt;, GSM2545352 &lt;dbl&gt;,\n#   GSM2545353 &lt;dbl&gt;, GSM2545354 &lt;dbl&gt;, GSM2545362 &lt;dbl&gt;, GSM2545363 &lt;dbl&gt;,\n#   GSM2545380 &lt;dbl&gt;\n\n\nTo convert the gene expression values from rna into a wide format, we need to create a new table where the values of the sample column would become the names of column variables.\nThe key point here is that we are still following a tidy data structure, but we have reshaped the data according to the observations of interest: expression levels per gene instead of recording them per gene and per sample.\nReshaping data from long to wide format can be performed with the function pivot_wider() from tidyr. For example:\n\nrna_wide &lt;- rna |&gt;                            \n1    select(gene, sample, expression) |&gt;\n    pivot_wider(\n2        names_from = sample,\n3        values_from = expression\n    )\n\nrna_wide\n\n\n1\n\nSelect columns gene, sample, and expression\n\n2\n\nColumns names of the wide table will be the values of the sample column\n\n3\n\nValues in the wide table will be the values of the expression column\n\n\n\n\n# A tibble: 1,474 × 23\n   gene    GSM2545336 GSM2545337 GSM2545338 GSM2545339 GSM2545340 GSM2545341\n   &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n 1 Asl           1170        361        400        586        626        988\n 2 Apod         36194      10347       9173      10620      13021      29594\n 3 Cyp2d22       4060       1616       1603       1901       2171       3349\n 4 Klk6           287        629        641        578        448        195\n 5 Fcrls           85        233        244        237        180         38\n 6 Slc2a4         782        231        248        265        313        786\n 7 Exd2          1619       2288       2235       2513       2366       1359\n 8 Gjc2           288        595        568        551        310        146\n 9 Plp1         43217     101241      96534      58354      53126      27173\n10 Gnb4          1071       1791       1867       1430       1355        798\n# ℹ 1,464 more rows\n# ℹ 16 more variables: GSM2545342 &lt;dbl&gt;, GSM2545343 &lt;dbl&gt;, GSM2545344 &lt;dbl&gt;,\n#   GSM2545345 &lt;dbl&gt;, GSM2545346 &lt;dbl&gt;, GSM2545347 &lt;dbl&gt;, GSM2545348 &lt;dbl&gt;,\n#   GSM2545349 &lt;dbl&gt;, GSM2545350 &lt;dbl&gt;, GSM2545351 &lt;dbl&gt;, GSM2545352 &lt;dbl&gt;,\n#   GSM2545353 &lt;dbl&gt;, GSM2545354 &lt;dbl&gt;, GSM2545362 &lt;dbl&gt;, GSM2545363 &lt;dbl&gt;,\n#   GSM2545380 &lt;dbl&gt;\n\n\nTo reshape data back to the long format, we would use the function pivot_longer().\n\nrna_long &lt;- rna_wide |&gt;\n    pivot_longer(\n1        -gene,\n2        names_to = \"sample\",\n3        values_to = \"expression\"\n    )\n\nrna_long\n\n\n1\n\nUse all columns except gene.\n\n2\n\nColumn names of the wide table will become a variable named sample\n\n3\n\nValues in the wide table will become a variable named expression\n\n\n\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\nPractice\n\n\n\nStarting from the rna table, use the pivot_wider() function to create a wide-format table giving the gene expression levels in each mouse. Then use the pivot_longer() function to restore a long-format table.\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\nrna1 &lt;- rna |&gt;\n    select(gene, mouse, expression) |&gt;\n    pivot_wider(names_from = mouse, values_from = expression)\n\nrna1\n\n# A tibble: 1,474 × 23\n   gene     `14`    `9`  `10`  `15`  `18`   `6`   `5`  `11`  `22`  `13`  `23`\n   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 Asl      1170    361   400   586   626   988   836   535   586   597   938\n 2 Apod    36194  10347  9173 10620 13021 29594 24959 13668 13230 15868 27769\n 3 Cyp2d22  4060   1616  1603  1901  2171  3349  3122  2008  2254  2277  2985\n 4 Klk6      287    629   641   578   448   195   186  1101   537   567   327\n 5 Fcrls      85    233   244   237   180    38    68   375   199   177    89\n 6 Slc2a4    782    231   248   265   313   786   528   249   266   357   654\n 7 Exd2     1619   2288  2235  2513  2366  1359  1474  3126  2379  2173  1531\n 8 Gjc2      288    595   568   551   310   146   186   791   454   370   240\n 9 Plp1    43217 101241 96534 58354 53126 27173 28728 98658 61356 61647 38019\n10 Gnb4     1071   1791  1867  1430  1355   798   806  2437  1394  1554   960\n# ℹ 1,464 more rows\n# ℹ 11 more variables: `24` &lt;dbl&gt;, `8` &lt;dbl&gt;, `7` &lt;dbl&gt;, `1` &lt;dbl&gt;, `16` &lt;dbl&gt;,\n#   `21` &lt;dbl&gt;, `4` &lt;dbl&gt;, `2` &lt;dbl&gt;, `20` &lt;dbl&gt;, `12` &lt;dbl&gt;, `19` &lt;dbl&gt;\n\nrna1 |&gt;\n    pivot_longer(-gene, names_to = \"mouse_id\", values_to = \"counts\")\n\n# A tibble: 32,428 × 3\n   gene  mouse_id counts\n   &lt;chr&gt; &lt;chr&gt;     &lt;dbl&gt;\n 1 Asl   14         1170\n 2 Asl   9           361\n 3 Asl   10          400\n 4 Asl   15          586\n 5 Asl   18          626\n 6 Asl   6           988\n 7 Asl   5           836\n 8 Asl   11          535\n 9 Asl   22          586\n10 Asl   13          597\n# ℹ 32,418 more rows"
  },
  {
    "objectID": "chapters/02_tidyverse.html#exporting-data",
    "href": "chapters/02_tidyverse.html#exporting-data",
    "title": "2  Data processing with the tidyverse",
    "section": "2.5 Exporting data",
    "text": "2.5 Exporting data\nFinally, to export tabular data, we will use the write_* functions from the tidyr package. Here, we will export the tibble rna_wide to a .csv file. For that, we will use the function write_csv().\n\nwrite_csv(rna_wide, file = here(\"output\", \"rna_wide.csv\"))"
  },
  {
    "objectID": "chapters/03_visualization.html#goals-of-this-lesson",
    "href": "chapters/03_visualization.html#goals-of-this-lesson",
    "title": "3  Visualizing data with ggplot2",
    "section": "3.1 Goals of this lesson",
    "text": "3.1 Goals of this lesson\nAt the end of this lesson, you will be able to:\n\ncreate plots with ggplot2 for different kinds of data\ncustomize plots\narrange plots in complex figures"
  },
  {
    "objectID": "chapters/03_visualization.html#plotting-with-ggplot2",
    "href": "chapters/03_visualization.html#plotting-with-ggplot2",
    "title": "3  Visualizing data with ggplot2",
    "section": "3.2 Plotting with ggplot2",
    "text": "3.2 Plotting with ggplot2\nggplot2 functions like data in the ‘long’ format, i.e., a column for every dimension, and a row for every observation. Well-structured data will save you lots of time when making figures with ggplot2.\nggplot graphics are built step by step by adding new elements. Adding layers in this fashion allows for extensive flexibility and customization of plots. As stated in RStudio’s Data Visualization Cheat Sheet:\n\nThe idea behind the Grammar of Graphics it is that you can build every graph from the same 3 components: (1) a data set, (2) a coordinate system, and (3) geoms — i.e. visual marks that represent data points.\n\nTo build a ggplot, we will use the following basic template that can be used for different types of plots:\n\nggplot(&lt;DATA&gt;, aes(&lt;MAPPINGS&gt;)) + \n  &lt;GEOM_FUNCTION&gt;()\n\nFor example:\n\nggplot(                    \n1    rna,\n2    aes(x = expression)\n) +\n3  geom_histogram()\n\n\n1\n\nUse the ggplot() function and bind the plot to a specific data frame using the data argument.\n\n2\n\nDefine a mapping (using the aesthetic (aes) function), by selecting the variables to be plotted and specifying how to present them in the graph, e.g. as x/y positions or characteristics such as size, shape, color, etc.\n\n3\n\nAdd ‘geoms’ - geometries, or graphical representations of the data in the plot (points, lines, bars). ggplot2 offers many different geoms.\n\n\n\n\n\n\n\nggplot2 offers many different geometries, such as:\n\ngeom_point() for scatter plots, dot plots, etc.\ngeom_histogram() for histograms\ngeom_boxplot() for boxplots\ngeom_line() for trend lines, time series, etc\nand much more!\n\nBesides, several people have extended the ggplot2 ecosystem by creating new packages with geoms that are field-specific (e.g., geom_nodes() from the package ggnetwork to plot networks).\n\n\n\n\n\n\nPractice\n\n\n\nYou have probably noticed an automatic message that appears when drawing the histogram:\nChange the arguments bins or binwidth of geom_histogram() to change the number or width of the bins.\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Change bins\nggplot(rna, aes(x = expression)) +\n    geom_histogram(bins = 15)\n\n\n\n# Change binwidth\nggplot(rna, aes(x = expression)) +\n    geom_histogram(binwidth = 2000)\n\n\n\n\n\n\n\n\n\nWe can observe here that the data are skewed to the right. We can apply log2 transformation to have a more symmetric distribution. Note that we add here a small constant value (+1) to avoid having -Inf values returned for expression values equal to 0.\n\nrna &lt;- rna %&gt;%\n  mutate(expression_log = log2(expression + 1))\n\nIf we now draw the histogram of the log2-transformed expressions, the distribution is indeed closer to a normal distribution.\n\nggplot(rna, aes(x = expression_log)) + \n    geom_histogram()\n\n\n\n\nFrom now on we will work on the log-transformed expression values."
  },
  {
    "objectID": "chapters/03_visualization.html#building-your-plots-iteratively",
    "href": "chapters/03_visualization.html#building-your-plots-iteratively",
    "title": "3  Visualizing data with ggplot2",
    "section": "3.3 Building your plots iteratively",
    "text": "3.3 Building your plots iteratively\nWe will now draw a scatter plot with two continuous variables and the geom_point() function. This graph will represent the log2 fold changes of expression comparing time 8 versus time 0, and time 4 versus time 0. To this end, we first need to compute the means of the log-transformed expression values by gene and time, then the log fold changes by subtracting the mean log expressions between time 8 and time 0 and between time 4 and time 0. Note that we also include here the gene biotype that we will use later on to represent the genes. We will save the fold changes in a new data frame called rna_fc.\n\nrna_fc &lt;- rna |&gt;\n    select(gene, time, gene_biotype, expression_log) |&gt;\n    group_by(gene, time, gene_biotype) |&gt;\n    summarise(mean_exp = mean(expression_log)) |&gt;\n    pivot_wider(names_from = time, values_from = mean_exp) |&gt;\n    mutate(time_8_vs_0 = `8` - `0`, time_4_vs_0 = `4` - `0`)\n\nhead(rna_fc)\n\n# A tibble: 6 × 7\n# Groups:   gene [6]\n  gene     gene_biotype     `0`   `4`   `8` time_8_vs_0 time_4_vs_0\n  &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n1 AI504432 lncRNA         10.0  10.1   9.97     -0.0357      0.0754\n2 AW046200 lncRNA          7.28  7.23  6.35     -0.930      -0.0497\n3 AW551984 protein_coding  7.86  7.26  8.19      0.334      -0.596 \n4 Aamp     protein_coding 12.2  12.2  12.2       0.0391      0.0754\n5 Abca12   protein_coding  2.51  2.34  2.33     -0.180      -0.173 \n6 Abcc8    protein_coding 11.3  11.3  11.2      -0.164       0.0234\n\n\nWe can then build a ggplot with the newly created dataset rna_fc. Building plots with ggplot2 is typically an iterative process. We start by defining the dataset we’ll use, lay out the axes, and choose a geom:\n\nggplot(rna_fc, aes(x = time_4_vs_0, y = time_8_vs_0)) +\n    geom_point()\n\n\n\n\nThen, we start modifying this plot to extract more information from it. For instance, we can add transparency (alpha) to avoid overplotting:\n\nggplot(rna_fc, aes(x = time_4_vs_0, y = time_8_vs_0)) +\n    geom_point(alpha = 0.3)\n\n\n\n\nWe can also add colors for all the points:\n\nggplot(rna_fc, aes(x = time_4_vs_0, y = time_8_vs_0)) +\n    geom_point(alpha = 0.3, color = \"blue\")\n\n\n\n\nOr to color each gene in the plot differently, you could use a vector as an input to the argument color. ggplot2 will provide a different color corresponding to different values in the vector. Here is an example where we color with gene_biotype:\n\nggplot(rna_fc, aes(x = time_4_vs_0, y = time_8_vs_0)) +\n    geom_point(alpha = 0.3, aes(color = gene_biotype))\n\n\n\n\nWe can also specify the colors directly inside the mapping provided in the ggplot() function. This will be seen by any geom layers and the mapping will be determined by the x- and y-axis set up in aes().\n\nggplot(rna_fc, aes(x = time_4_vs_0, y = time_8_vs_0, color = gene_biotype)) +\n    geom_point(alpha = 0.3)\n\n\n\n\nFinally, we could also add a diagonal line with the geom_abline() function:\n\nggplot(rna_fc, aes(x = time_4_vs_0, y = time_8_vs_0, color = gene_biotype)) +\n    geom_point(alpha = 0.3) +\n    geom_abline(intercept = 0)\n\n\n\n\nNotice that we can change the geom layer from geom_point to geom_jitter and colors will still be determined by gene_biotype.\n\nggplot(rna_fc, aes(x = time_4_vs_0, y = time_8_vs_0, color = gene_biotype)) +\n    geom_jitter(alpha = 0.3) +\n    geom_abline(intercept = 0)\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nUse what you just learned to create a scatter plot of expression_log over sample from the rna dataset with the time showing in different colors. Is this a good way to show this type of data?\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\nggplot(rna, aes(y = expression_log, x = sample)) +\n    geom_point(aes(color = time))"
  },
  {
    "objectID": "chapters/03_visualization.html#visualizing-distributions",
    "href": "chapters/03_visualization.html#visualizing-distributions",
    "title": "3  Visualizing data with ggplot2",
    "section": "3.4 Visualizing distributions",
    "text": "3.4 Visualizing distributions\nWe can use boxplots to visualize the distribution of gene expressions within each sample:\n\nggplot(rna, aes(y = expression_log, x = sample)) +\n    geom_boxplot()\n\n\n\n\nBy adding points to the boxplot, we can have a better idea of the number of measurements and of their distribution:\n\nggplot(rna, aes(y = expression_log, x = sample)) +\n    geom_jitter(alpha = 0.2, color = \"tomato\") +\n    geom_boxplot(alpha = 0)\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nNote how the boxplot layer is in front of the jitter layer? What do you need to change in the code to put the boxplot behind the points?\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\nWe should switch the order of these two geoms:\n\nggplot(rna, aes(y = expression_log, x = sample)) +\n    geom_boxplot(alpha = 0) +\n    geom_jitter(alpha = 0.2, color = \"tomato\")\n\n\n\n\n\n\n\n\n\nYou may notice that the values on the x-axis are still not properly readable. Let’s change the orientation of the labels and adjust them vertically and horizontally so they don’t overlap. You can use a 90-degree angle, or experiment to find the appropriate angle for diagonally oriented labels:\n\nggplot(rna, aes(y = expression_log, x = sample)) +\n    geom_jitter(alpha = 0.2, color = \"tomato\") +\n    geom_boxplot(alpha = 0) +\n    theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5))\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\n\nAdd color to the data points on your boxplot according to the duration of the infection (time). Hint: Check the class for time. Consider changing the class of time from integer to factor directly in the ggplot mapping. Why does this change how R makes the graph?\nBoxplots are useful summaries, but hide the shape of the distribution. For example, if the distribution is bimodal, we would not see it in a boxplot. An alternative to the boxplot is the violin plot, where the shape (of the density of points) is drawn.\n\nReplace the box plot with a violin plot; see geom_violin(). Fill in the violins according to the time with the argument fill.\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Q1\nggplot(rna, aes(y = expression_log, x = sample)) +\n    geom_jitter(alpha = 0.2, aes(color = as.factor(time))) +\n    geom_boxplot(alpha = 0) +\n    theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5))\n\n\n\n# Q2\nggplot(rna, aes(y = expression_log, x = sample)) +\n    geom_violin(aes(fill = as.factor(time))) +\n    theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5))"
  },
  {
    "objectID": "chapters/03_visualization.html#line-plots",
    "href": "chapters/03_visualization.html#line-plots",
    "title": "3  Visualizing data with ggplot2",
    "section": "3.5 Line plots",
    "text": "3.5 Line plots\nLine plots are an excellent way of visualizing time-series data. Here, we will calculate the mean expression per duration of the infection for the 10 genes having the highest log fold changes comparing time 8 versus time 0. First, we need to select the genes and create a subset of rna called sub_rna containing the 10 selected genes. Then, we need to group the data and calculate the mean gene expression within each group:\n\n# Get genes with highest fold changes comparing time points 8 to 0\ngenes_selected &lt;- rna_fc |&gt;\n    arrange(-time_8_vs_0) |&gt;\n    head(n = 10) |&gt;\n    pull(gene) \n\n\n# Get mean expression by time\nmean_exp_by_time &lt;- rna |&gt;\n    filter(gene %in% genes_selected) |&gt;\n    group_by(gene, time) |&gt;\n    summarise(mean_exp = mean(expression_log))\n\nmean_exp_by_time\n\n# A tibble: 30 × 3\n# Groups:   gene [10]\n   gene   time mean_exp\n   &lt;chr&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Acr       0     5.07\n 2 Acr       4     5.54\n 3 Acr       8     7.31\n 4 Aipl1     0     3.70\n 5 Aipl1     4     3.89\n 6 Aipl1     8     6.56\n 7 Bst1      0     3.20\n 8 Bst1      4     3.77\n 9 Bst1      8     5.22\n10 Chil3     0     4.00\n# ℹ 20 more rows\n\n\nWe can build the line plot with duration of the infection on the x-axis and the mean expression on the y-axis:\n\nggplot(mean_exp_by_time, aes(x = time, y = mean_exp)) +\n    geom_line()\n\n\n\n\nUnfortunately, this does not work because we plotted data for all the genes together. We need to tell ggplot to draw a line for each gene by modifying the aesthetic function to include group = gene:\n\nggplot(mean_exp_by_time, aes(x = time, y = mean_exp, group = gene)) +\n    geom_line()\n\n\n\n\nWe will be able to distinguish genes in the plot if we add colors (using color also automatically groups the data):\n\nggplot(mean_exp_by_time, aes(x = time, y = mean_exp, color = gene)) +\n    geom_line()"
  },
  {
    "objectID": "chapters/03_visualization.html#faceting",
    "href": "chapters/03_visualization.html#faceting",
    "title": "3  Visualizing data with ggplot2",
    "section": "3.6 Faceting",
    "text": "3.6 Faceting\nggplot2 has a special technique called faceting that allows the user to split one plot into multiple (sub) plots based on a factor included in the dataset. These different subplots inherit the same properties (axes limits, ticks, …) to facilitate their direct comparison. We will use it to make a line plot across time for each gene:\n\nggplot(mean_exp_by_time, aes(x = time, y = mean_exp)) + \n    geom_line() +\n    facet_wrap(~gene)\n\n\n\n\nHere both x- and y-axis have the same scale for all the subplots. You can change this default behavior by modifying scales in order to allow a free scale for the y-axis:\n\nggplot(mean_exp_by_time, aes(x = time, y = mean_exp)) +\n    geom_line() +\n    facet_wrap(~gene, scales = \"free_y\")\n\n\n\n\nNow, we would like to split the line in each plot by the sex of the mice. To do that, we need to calculate the mean expression in the data frame grouped by gene, time, and sex:\n\nmean_exp_by_time_sex &lt;- rna |&gt;\n    filter(gene %in% genes_selected) |&gt;\n    group_by(gene, time, sex) |&gt;\n    summarise(mean_exp = mean(expression_log))\n\nmean_exp_by_time_sex\n\n# A tibble: 60 × 4\n# Groups:   gene, time [30]\n   gene   time sex    mean_exp\n   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;\n 1 Acr       0 Female     5.13\n 2 Acr       0 Male       5.00\n 3 Acr       4 Female     5.93\n 4 Acr       4 Male       5.15\n 5 Acr       8 Female     7.27\n 6 Acr       8 Male       7.36\n 7 Aipl1     0 Female     3.67\n 8 Aipl1     0 Male       3.73\n 9 Aipl1     4 Female     4.07\n10 Aipl1     4 Male       3.72\n# ℹ 50 more rows\n\n\nWe can now make the faceted plot by splitting further by sex using color (within a single plot):\n\nggplot(mean_exp_by_time_sex, aes(x = time, y = mean_exp, color = sex)) +\n    geom_line() +\n    facet_wrap(~gene, scales = \"free_y\")\n\n\n\n\nUsually, plots with white background look more readable when printed. We can set the background to white using the function theme_bw(). Additionally, we can remove the grid:\n\nggplot(mean_exp_by_time_sex, aes(x = time, y = mean_exp, color = sex)) +\n    geom_line() +\n    facet_wrap(~gene, scales = \"free_y\") +\n    theme_bw() +\n    theme(panel.grid = element_blank())\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nUse what you just learned to create a plot that depicts how the average expression of each chromosome changes through the duration of infection.\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\nmean_exp_by_chromosome &lt;- rna |&gt;\n    group_by(chromosome_name, time) |&gt;\n    summarize(mean_exp = mean(expression_log))\n\nggplot(mean_exp_by_chromosome, aes(x = time, y = mean_exp)) +\n    geom_line() +\n    facet_wrap(~chromosome_name, scales = \"free_y\")\n\n\n\n\n\n\n\n\n\nThe facet_wrap geometry extracts plots into an arbitrary number of dimensions to allow them to cleanly fit on one page. On the other hand, the facet_grid geometry allows you to explicitly specify how you want your plots to be arranged via formula notation (rows ~ columns; a . can be used as a placeholder that indicates only one row or column).\nLet’s modify the previous plot to compare how the mean gene expression of males and females has changed through time:\n\n# Create plot\np &lt;- ggplot(mean_exp_by_time_sex, aes(x = time, y = mean_exp, color = gene)) +\n    geom_line()\n\n# One column, facet by rows\np + facet_grid(sex ~ .)\n\n\n\n# One row, facet by column\np + facet_grid(. ~ sex)\n\n\n\n\n\n\n\n\n\n\nFriendly tip: ggplot2 themes\n\n\n\nIn addition to theme_bw(), which changes the plot background to white, ggplot2 comes with several other themes which can be useful to quickly change the look of your visualization. The complete list of themes is available at https://ggplot2.tidyverse.org/reference/ggtheme.html. theme_minimal() and theme_light() are popular, and theme_void() can be useful as a starting point to create a new hand-crafted theme.\nThe ggthemes package provides a wide variety of options (including an Excel 2003 theme). The ggplot2 extensions website provides a list of packages that extend the capabilities of ggplot2, including additional themes."
  },
  {
    "objectID": "chapters/03_visualization.html#customisation",
    "href": "chapters/03_visualization.html#customisation",
    "title": "3  Visualizing data with ggplot2",
    "section": "3.7 Customisation",
    "text": "3.7 Customisation\nLet’s come back to the faceted plot of mean expression by time and gene, colored by sex.\nTake a look at the ggplot2 cheat sheet, and think of ways you could improve the plot.\nNow, we can change names of axes to something more informative than ‘time’ and ‘mean_exp’, and add a title to the figure:\n\nggplot(mean_exp_by_time_sex, aes(x = time, y = mean_exp, color = sex)) +\n    geom_line() +\n    facet_wrap(~gene, scales = \"free_y\") +\n    theme_bw() +\n    theme(panel.grid = element_blank()) +\n    labs(\n        title = \"Mean gene expression by duration of the infection\",\n        x = \"Duration of the infection (in days)\",\n        y = \"Mean gene expression\"\n    )\n\n\n\n\nThe axes have more informative names, but their readability can be improved by increasing the font size:\n\nggplot(mean_exp_by_time_sex, aes(x = time, y = mean_exp, color = sex)) +\n    geom_line() +\n    facet_wrap(~gene, scales = \"free_y\") +\n    theme_bw() +\n    theme(panel.grid = element_blank()) +\n    labs(\n        title = \"Mean gene expression by duration of the infection\",\n        x = \"Duration of the infection (in days)\",\n        y = \"Mean gene expression\"\n    ) +\n    theme(text = element_text(size = 16))"
  },
  {
    "objectID": "chapters/03_visualization.html#composing-plots",
    "href": "chapters/03_visualization.html#composing-plots",
    "title": "3  Visualizing data with ggplot2",
    "section": "3.8 Composing plots",
    "text": "3.8 Composing plots\nFaceting is a great tool for splitting one plot into multiple subplots, but sometimes you may want to produce a single figure that contains multiple independent plots, i.e. plots that are based on different variables or even different data frames.\nLet’s start by creating the two plots that we want to arrange next to each other:\nThe first graph counts the number of unique genes per chromosome. We first need to reorder the levels of chromosome_name and filter the unique genes per chromosome. We also change the scale of the y-axis to a log10 scale for better readability.\n\np_genecount &lt;- rna |&gt;\n    mutate(\n        chromosome_name = factor(chromosome_name, levels = c(1:19, \"X\", \"Y\"))\n    ) |&gt;\n    select(chromosome_name, gene) |&gt;\n    distinct() |&gt;\n    ggplot() +\n    geom_bar(\n        aes(x = chromosome_name), fill = \"seagreen\",\n        position = \"dodge\", stat = \"count\"\n    ) +\n    labs(y = \"log10(n genes)\", x = \"chromosome\") +\n    scale_y_log10()\n\np_genecount\n\n\n\n\nBelow, we also remove the legend altogether by setting the legend.position to \"none\".\n\np_box &lt;- ggplot(rna, aes(y = expression_log, x = as.factor(time), color = sex)) +\n    geom_boxplot(alpha = 0) +\n    labs(y = \"Mean gene exp\", x = \"time\") + \n    theme(legend.position = \"none\")\n\np_box\n\n\n\n\nThe patchwork package provides an elegant approach to combining figures using the + to arrange figures (typically side by side). More specifically the | explicitly arranges them side by side and / stacks them on top of each other.\n\nlibrary(\"patchwork\")\np_genecount + p_box\n\n\n\n\n\np_genecount / p_box\n\n\n\n\nWe can combine further control the layout of the final composition with plot_layout to create more complex layouts:\n\np_genecount + p_box + plot_layout(ncol = 1)\n\n\n\n\n\np_genecount +\n (p_genecount + p_box) +\n p_box +\n plot_layout(ncol = 1)\n\n\n\np_genecount /\n    (p_genecount + p_box) /\n    p_box\n\n\n\n\nLearn more about patchwork on its webpage."
  },
  {
    "objectID": "chapters/03_visualization.html#exporting-plots",
    "href": "chapters/03_visualization.html#exporting-plots",
    "title": "3  Visualizing data with ggplot2",
    "section": "3.9 Exporting plots",
    "text": "3.9 Exporting plots\nAfter creating your plot, you can save it to a file in your favorite format. The Export tab in the Plot pane in RStudio will save your plots at low resolution, which will not be accepted by many journals and will not scale well for posters.\nInstead, use the ggsave() function, which allows you easily change the dimension and resolution of your plot by adjusting the appropriate arguments (width, height and dpi).\n\nmy_plot &lt;- ggplot(mean_exp_by_time_sex, aes(x = time, y = mean_exp, color = sex)) +\n    geom_line() +\n    facet_wrap(~gene, scales = \"free_y\") +\n    labs(\n        title = \"Mean gene expression by duration of the infection\",\n        x = \"Duration of the infection (in days)\",\n        y = \"Mean gene expression\"\n    ) +\n    guides(color = guide_legend(title = \"Gender\")) +\n    theme_bw() +\n    theme(\n        axis.text.x = element_text(colour = \"royalblue4\", size = 12),\n        axis.text.y = element_text(colour = \"royalblue4\", size = 12),\n        text = element_text(size = 16),\n        legend.position = \"top\"\n    )\n\n\nggsave(\n    my_plot, \n    file = here(\"output\", \"figs\", \"mean_exp_by_time_sex.png\"),\n    width = 15, height = 10, dpi = 300\n)"
  },
  {
    "objectID": "chapters/04_bioc.html#goals-of-this-lesson",
    "href": "chapters/04_bioc.html#goals-of-this-lesson",
    "title": "4  Analyzing biological data with the Bioconductor ecosystem",
    "section": "4.1 Goals of this lesson",
    "text": "4.1 Goals of this lesson\nAt the end of this lesson, you will be able to:\n\nread and process sequence data with Biostrings\nread and process genomic coordinates with GenomicRanges\nread and process quantitative data (e.g., gene expression) with SummarizedExperiment"
  },
  {
    "objectID": "chapters/04_bioc.html#working-with-sequences-the-biostrings-package",
    "href": "chapters/04_bioc.html#working-with-sequences-the-biostrings-package",
    "title": "4  Analyzing biological data with the Bioconductor ecosystem",
    "section": "4.2 Working with sequences: the Biostrings package",
    "text": "4.2 Working with sequences: the Biostrings package\nThe Biostrings package allows efficient manipulation of biological sequences, and its data classes are standard for all Bioconductor packages that involve sequence analyses. The data classes in Biostrings to represent sets of biological sequences are:\n\nDNAStringSet: for sets of DNA strings.\nRNAStringSet: for sets of RNA strings.\nAAStringSet: for sets of amino acid strings.\n\nFor a single sequence, the each of the above has a correspoding XString class (i.e., DNAString, RNAString, AAString). For example, let’s create some XString objects manually:\n\n# Create `DNAString` object\ndna_seq &lt;- DNAString(\"ATGGCCGACTCA\")\ndna_seq\n\n12-letter DNAString object\nseq: ATGGCCGACTCA\n\n# Convert `DNAString` to `RNAString`\nrna_seq &lt;- RNAString(dna_seq)\nrna_seq\n\n12-letter RNAString object\nseq: AUGGCCGACUCA\n\n# Translate `RNAString` to create `AAString`\naa_seq &lt;- translate(rna_seq)\naa_seq\n\n4-letter AAString object\nseq: MADS\n\n\nIn real-world data analyses, we would work with multiple sequences (e.g., a whole genome or a whole proteome). Multiple sequences are stored in XStringSet objects, which can be read from FASTA files with readXStringSet() functions, namely:\n\nreadDNAStringSet(): read FASTA file containing multiple DNA sequences.\nreadRNAStringSet(): read FASTA file containing multiple RNA sequences.\nreadAAStringSet(): read FASTA file containing multiple AA sequences.\n\nFor example, let’s read an example FASTA file that come with the Biostrings package.\n\n# Path to FASTA file containing an ORF\nfasta_file &lt;- system.file(\"extdata\", \"someORF.fa\", package = \"Biostrings\")\nfasta_file\n\n[1] \"/home/faalm/R/x86_64-pc-linux-gnu-library/4.3/Biostrings/extdata/someORF.fa\"\n\n# Read FASTA file as a DNAStringSet object\ndna_seqs &lt;- readDNAStringSet(fasta_file)\ndna_seqs\n\nDNAStringSet object of length 7:\n    width seq                                               names               \n[1]  5573 ACTTGTAAATATATCTTTTATTT...CTTATCGACCTTATTGTTGATAT YAL001C TFC3 SGDI...\n[2]  5825 TTCCAAGGCCGATGAATTCGACT...AGTAAATTTTTTTCTATTCTCTT YAL002W VPS8 SGDI...\n[3]  2987 CTTCATGTCAGCCTGCACTTCTG...TGGTACTCATGTAGCTGCCTCAT YAL003W EFB1 SGDI...\n[4]  3929 CACTCATATCGGGGGTCTTACTT...TGTCCCGAAACACGAAAAAGTAC YAL005C SSA1 SGDI...\n[5]  2648 AGAGAAAGAGTTTCACTTCTTGA...ATATAATTTATGTGTGAACATAG YAL007C ERP2 SGDI...\n[6]  2597 GTGTCCGGGCCTCGCAGGCGTTC...AAGTTTTGGCAGAATGTACTTTT YAL008W FUN14 SGD...\n[7]  2780 CAAGATAATGTCAAAGTTAGTGG...GCTAAGGAAGAAAAAAAAATCAC YAL009W SPO7 SGDI...\n\n\nSome examples of what you can do to explore XStringSet objects include:\n\n# width(): get sequence lengths\nwidth(dna_seqs)\n\n[1] 5573 5825 2987 3929 2648 2597 2780\n\n# names(): get sequence names\nnames(dna_seqs)\n\n[1] \"YAL001C TFC3 SGDID:S0000001, Chr I from 152168-146596, reverse complement, Verified ORF\"\n[2] \"YAL002W VPS8 SGDID:S0000002, Chr I from 142709-148533, Verified ORF\"                    \n[3] \"YAL003W EFB1 SGDID:S0000003, Chr I from 141176-144162, Verified ORF\"                    \n[4] \"YAL005C SSA1 SGDID:S0000004, Chr I from 142433-138505, reverse complement, Verified ORF\"\n[5] \"YAL007C ERP2 SGDID:S0000005, Chr I from 139347-136700, reverse complement, Verified ORF\"\n[6] \"YAL008W FUN14 SGDID:S0000006, Chr I from 135916-138512, Verified ORF\"                   \n[7] \"YAL009W SPO7 SGDID:S0000007, Chr I from 134856-137635, Verified ORF\"                    \n\n# subset DNAStringSet and create a DNAStringSet of length 1\ndna_seqs[1]\n\nDNAStringSet object of length 1:\n    width seq                                               names               \n[1]  5573 ACTTGTAAATATATCTTTTATTT...CTTATCGACCTTATTGTTGATAT YAL001C TFC3 SGDI...\n\n# subset DNAStringSet and create a DNAString object\ndna_seqs[[1]]\n\n5573-letter DNAString object\nseq: ACTTGTAAATATATCTTTTATTTTCCGAGAGGAAAA...AATTTCTTAAACGCTTATCGACCTTATTGTTGATAT\n\n\nAll functions above would also work for AAStringSet objects and RNAStringSet objects.\n\n\n\n\n\n\nPractice\n\n\n\nUse the dna_seqs object created above to answer the following questions:\n\nWhat is the length of the 3rd sequence?\nWhat is the name of the 5th sequence?\nHow many times does the TTCC sequence string occur in each sequence? Hint: use the function vcountPattern().\nWhat are the first 3 nucleotides of each sequence? Hint: use the subseq() function.\n\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Q1: Length of the 3rd sequence\nwidth(dna_seqs)[3]\n\n[1] 2987\n\n# Q2: Name of the 5th sequence\nnames(dna_seqs)[5]\n\n[1] \"YAL007C ERP2 SGDID:S0000005, Chr I from 139347-136700, reverse complement, Verified ORF\"\n\n# Q3: Minimum and maximum temperature\nvcountPattern(\"TTCC\", dna_seqs)\n\n[1] 21 28 16 23 15  8  5\n\n# Q4: First 3 nucleotides of each sequence\nsubseq(dna_seqs, start = 1, end = 3)\n\nDNAStringSet object of length 7:\n    width seq                                               names               \n[1]     3 ACT                                               YAL001C TFC3 SGDI...\n[2]     3 TTC                                               YAL002W VPS8 SGDI...\n[3]     3 CTT                                               YAL003W EFB1 SGDI...\n[4]     3 CAC                                               YAL005C SSA1 SGDI...\n[5]     3 AGA                                               YAL007C ERP2 SGDI...\n[6]     3 GTG                                               YAL008W FUN14 SGD...\n[7]     3 CAA                                               YAL009W SPO7 SGDI..."
  },
  {
    "objectID": "chapters/04_bioc.html#working-with-genomic-ranges-the-genomicranges-package",
    "href": "chapters/04_bioc.html#working-with-genomic-ranges-the-genomicranges-package",
    "title": "4  Analyzing biological data with the Bioconductor ecosystem",
    "section": "4.3 Working with genomic ranges: the GenomicRanges package",
    "text": "4.3 Working with genomic ranges: the GenomicRanges package\nThe GenomicRanges package implements S4 classes to represent genomic ranges as S4 objects.\nSpecifically, the GRanges class is designed to store a set of intervals including the name of the sequence where features are located as well as the range of integer coordinates spanned by the feature in that sequence.\nMore generally, the IRanges class is designed to store a set of intervals over a range of integer coordinates, without the notion of sequence names. As such, a GRanges object is merely the combination of an IRanges object and a vector of sequence names.\nThose S4 classes provide automatic validity-checking functionality, and a range of methods implementing common operations on integer intervals and genomic ranges, from the calculation of distance between pairs of intervals to the identification of overlapping genomic ranges.\n\n4.3.1 The IRanges class\nWhile the genomic space of many organisms is subdivided into multiple sequences (e.g., chromosomes), many operations on genomic ranges take place within individual sequences, where only integer positions matter. The IRanges class provides a container for such “simple” ranges that are defined by two out of three pieces of information:\n\nthe start position of the range\nthe width of the range\nthe end position of the range\n\nThe IRanges() constructor function accepts those three pieces of information in the arguments start=, width=, and end=. For instance, we create two integer ranges from their start position and width:\n\none range starts at position 10 and has width 10\none range starts at position 15 and has width 5\n\n\ndemo_iranges &lt;- IRanges(start = c(10, 15), width = c(10, 5))\ndemo_iranges\n\nIRanges object with 2 ranges and 0 metadata columns:\n          start       end     width\n      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;\n  [1]        10        19        10\n  [2]        15        19         5\n\n\nWe note how the object displays not only the start and width information that we requested for each range, but also the end position that is naturally computed from the other two pieces of information.\n\n\n\n\n\n\nPractice\n\n\n\nCreate the same two ranges as above, using the arguments start= and end= of the IRanges() constructor function.\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\nIRanges(start = c(10, 15), end = c(19, 19))\n\nIRanges object with 2 ranges and 0 metadata columns:\n          start       end     width\n      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;\n  [1]        10        19        10\n  [2]        15        19         5\n\n\n\n\n\n\n\nThe start and end positions as well as the width of every interval can be extracted as numeric vector using the functions start(), end() and width(), respectively.\n\nstart(demo_iranges)\n\n[1] 10 15\n\nend(demo_iranges)\n\n[1] 19 19\n\nwidth(demo_iranges)\n\n[1] 10  5\n\n\nObjects of the IRanges family extend the Vector class, and are handled as unidimensional vectors in terms of indexing. As such, individual ranges can be extracted by integer index like any regular vector.\n\ndemo_iranges[1]\n\nIRanges object with 1 range and 0 metadata columns:\n          start       end     width\n      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;\n  [1]        10        19        10\n\n\n\n\n4.3.2 Metadata on IRanges\nThe IRanges class can accommodate metadata information on each range, including names - passed to the names= argument - and miscellaneous metadata passed as named vectors.\nFor instance, we create two ranges named “A” and “B”. Furthermore, we define metadata fields to store an example of character values and numeric values, respectively. Both the names and the values of the metadata fields are completely arbitrary in this example.\n\ndemo_with_metadata &lt;- IRanges(\n    start = c(10,  15),\n    end   = c(19,  19),\n    names = c(\"A\", \"B\"),\n    character_metadata = c(\"control\", \"target\"),\n    numeric_metadata = c(100, 200)\n)\n\ndemo_with_metadata\n\nIRanges object with 2 ranges and 2 metadata columns:\n        start       end     width | character_metadata numeric_metadata\n    &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; |        &lt;character&gt;        &lt;numeric&gt;\n  A        10        19        10 |            control              100\n  B        15        19         5 |             target              200\n\n\nThe metadata columns can be extracted as a DataFrame using the function mcols() (short for “metadata columns”).\n\nmcols(demo_with_metadata)\n\nDataFrame with 2 rows and 2 columns\n  character_metadata numeric_metadata\n         &lt;character&gt;        &lt;numeric&gt;\nA            control              100\nB             target              200\n\n\nThe character vector of names can be extracted using the function names().\n\nnames(demo_with_metadata)\n\n[1] \"A\" \"B\"\n\n\nSimilarly to named vector of base data types, individual ranges can be extracted by name.\n\ndemo_with_metadata[\"A\"]\n\nIRanges object with 1 range and 2 metadata columns:\n        start       end     width | character_metadata numeric_metadata\n    &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; |        &lt;character&gt;        &lt;numeric&gt;\n  A        10        19        10 |            control              100\n\n\n\n\n4.3.3 Operations on IRanges\nIRanges provide the basis for most operations on ranges of numerical coordinates.\nFor instance, given two sets of ranges - a query set and a subject set - the findOVerlaps() function can be used to find out which pairs of ranges in the two sets overlap with each other.\n\nquery_iranges &lt;- IRanges(\n    start = c(8, 16),\n    end   = c(14, 18)\n)\n\noverlaps_iranges &lt;- findOverlaps(query = query_iranges, subject = demo_iranges)\noverlaps_iranges\n\nHits object with 3 hits and 0 metadata columns:\n      queryHits subjectHits\n      &lt;integer&gt;   &lt;integer&gt;\n  [1]         1           1\n  [2]         2           1\n  [3]         2           2\n  -------\n  queryLength: 2 / subjectLength: 2\n\n\nThe results are returned in the form of a Hits object, which we have not introduced yet. A Hits object is visualised as a table that comprises two integer columns named queryHits and subjectHits. Each row in the table reports an overlap between one range in the query set and one range in the subject set, with the integer value in each column indicating the index of the range in each set involved in the overlap.\nIn this example, we confirm that the first range in the query set overlaps the first range in the subject set; while the second range in the query set overlaps both ranges in the subject set.\n\n\n4.3.4 The GRanges class\nHaving defined integer ranges, the only additional information necessary to define genomic ranges is the name of the genomic sequence on which each range is located.\nFor instance, we define two genomic ranges, as follows:\n\none genomic range on chromosome 1 (abbreviated “chr1”), from position 10 to 25\none genomic range on chromosome 2 (abbreviated “chr2”), from position 20 to 35\n\nTo do so, we use the GRanges() constructor function. We provide the sequence names as a character vector to the argument seqnames=, and we provide both the start and end position to the argument ranges= as an IRanges object.\n\ndemo_granges &lt;- GRanges(\n    seqnames = c(\"chr1\", \"chr2\"),\n    ranges = IRanges(\n        start = c(10, 20),\n        end   = c(25, 35))\n)\n\ndemo_granges\n\nGRanges object with 2 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;\n  [1]     chr1     10-25      *\n  [2]     chr2     20-35      *\n  -------\n  seqinfo: 2 sequences from an unspecified genome; no seqlengths\n\n\nIn the console, the object displays the sequence names in the seqnames component, and the ranges in the form start-end in the ranges component. Furthermore, the example above also demonstrate that GRanges objects possess a component called strand; the symbol * indicates unstranded genomic ranges, as we have not provided that information.\nThe strand information can be supplied to the strand= argument, for instance:\n\ndemo_granges2 &lt;- GRanges(\n    seqnames = c(\"chr1\", \"chr2\"),\n    ranges = IRanges(\n        start = c(10, 20),\n        end   = c(25, 35)),\n    strand  = c(\"+\", \"-\")\n)\n\ndemo_granges2\n\nGRanges object with 2 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;\n  [1]     chr1     10-25      +\n  [2]     chr2     20-35      -\n  -------\n  seqinfo: 2 sequences from an unspecified genome; no seqlengths\n\n\nFinally, the examples above also demonstrate that GRanges objects include a component called seqinfo, which is occasionally used to store information about each sequence that may be represented in the seqnames component. In the latest example above, we have not provide any information about any sequence. As such, the seqinfo component was automatically populated with the names of the sequences that we used to create the object, while the remaining pieces of information were left unspecified, as NA.\n\nseqinfo(demo_granges2)\n\nSeqinfo object with 2 sequences from an unspecified genome; no seqlengths:\n  seqnames seqlengths isCircular genome\n  chr1             NA         NA   &lt;NA&gt;\n  chr2             NA         NA   &lt;NA&gt;\n\n\nThe example above reveals that information about sequences include not only their respective name and length, but also whether they represent a circular polymer (e.g., plasmid), and the name of the genome that they are part of.\n\n\n4.3.5 Metadata on GRanges\nSimilarly to IRanges, metadata can be passed directly to the GRanges constructor function. For instance:\n\ndemo_granges3 &lt;- GRanges(\n    seqnames = c(\"chr1\", \"chr2\"),\n    ranges = IRanges(\n        start = c(10, 20),\n        end = c(25, 35)),\n    metadata1 = c(\"control\", \"target\"),\n    metadata2 = c(1, 2)\n)\n\ndemo_granges3\n\nGRanges object with 2 ranges and 2 metadata columns:\n      seqnames    ranges strand |   metadata1 metadata2\n         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt; &lt;numeric&gt;\n  [1]     chr1     10-25      * |     control         1\n  [2]     chr2     20-35      * |      target         2\n  -------\n  seqinfo: 2 sequences from an unspecified genome; no seqlengths\n\n\n\n\n4.3.6 Importing genomic ranges from files\nFrequently, large collections of genomic ranges are imported from files rather than described in manually written code. In particular, genome-wide annotations of known gene features are distributed as files on websites such as Ensembl.\nVarious file formats are commonly used to store genomic ranges in bioinformatics workflows. For instance, the BED (Browser Extensible Data) format is commonly found in Chromatin Immunoprecipitation Sequencing (ChIP-Seq), while GTF (Gene Transfer Format, GTF2.2) is the de facto standard file format to describe genomic features such as exons, transcripts, and genes.\nIn the following example, we import the gene model for Actin Beta (ACTB) from a small GTF file as a set of genomic ranges. The example file represents a subset of a GTF file for the Homo sapiens species, downloaded from Ensembl. The original file contains more than 3 millions lines and 22 metadata fields, from which a subset was extracted into a smaller file for this lesson.\nIn particular, we use the import() generic defined in the BiocIO package - with methods implemented in the rtracklayer package - as a versatile function that is capable of recognising common file extensions and associating them with the appropriate method for parsing each particular file format.\n\nlibrary(rtracklayer)\n\nactb_gtf_data &lt;- rtracklayer::import(here(\"data\", \"actb.gtf\"))\nactb_gtf_data\n\nGRanges object with 267 ranges and 7 metadata columns:\n        seqnames          ranges strand |      source           type     score\n           &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; |    &lt;factor&gt;       &lt;factor&gt; &lt;numeric&gt;\n    [1]        7 5526409-5563902      - | rtracklayer     gene              NA\n    [2]        7 5526409-5530601      - | rtracklayer     transcript        NA\n    [3]        7 5530542-5530601      - | rtracklayer     exon              NA\n    [4]        7 5529535-5529684      - | rtracklayer     exon              NA\n    [5]        7 5529535-5529657      - | rtracklayer     CDS               NA\n    ...      ...             ...    ... .         ...            ...       ...\n  [263]        7 5540676-5540771      - | rtracklayer five_prime_utr        NA\n  [264]        7 5529658-5529663      - | rtracklayer five_prime_utr        NA\n  [265]        7 5561852-5562716      - | rtracklayer transcript            NA\n  [266]        7 5562390-5562716      - | rtracklayer exon                  NA\n  [267]        7 5561852-5561949      - | rtracklayer exon                  NA\n            phase         gene_id   gene_name   transcript_id\n        &lt;integer&gt;     &lt;character&gt; &lt;character&gt;     &lt;character&gt;\n    [1]      &lt;NA&gt; ENSG00000075624        ACTB            &lt;NA&gt;\n    [2]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000674681\n    [3]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000674681\n    [4]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000674681\n    [5]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000674681\n    ...       ...             ...         ...             ...\n  [263]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000414620\n  [264]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000414620\n  [265]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000646584\n  [266]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000646584\n  [267]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000646584\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\n\nIn the example above, the contents of the GTF file were imported into a GRanges object. For each entry in the file, the sequence name, start and end position, and strand information were used to populate the dedicated components of the object, while all other pieces of information are stored as separate columns of metadata.\nFrom here on, this GRanges object can be manipulated just like any of the other GRanges objects that we have created earlier in this episode.\n\n\n4.3.7 Operations on GRanges and the GRangesList class\nAs we have demonstrated so far, GRanges objects can be manually defined or imported from files. Those often represent genomic regions of interest, and databases of known genomic features, respectively. Either way, a number of operations are commonly applied to GRanges objects throughout bioinformatics workflows.\n\n4.3.7.1 Subset\nFor instance, the subset() method is extremely convenient to extract a set of genomic ranges matching a condition on any component, including sequence name, start and end position, strand, or any metadata field. In the example below, we extract all the records of type transcript that start at position 5527147.\n\nsubset(actb_gtf_data, type == \"transcript\" & start == 5527147)\n\nGRanges object with 5 ranges and 7 metadata columns:\n      seqnames          ranges strand |      source       type     score\n         &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; |    &lt;factor&gt;   &lt;factor&gt; &lt;numeric&gt;\n  [1]        7 5527147-5529949      - | rtracklayer transcript        NA\n  [2]        7 5527147-5530581      - | rtracklayer transcript        NA\n  [3]        7 5527147-5530604      - | rtracklayer transcript        NA\n  [4]        7 5527147-5530604      - | rtracklayer transcript        NA\n  [5]        7 5527147-5530604      - | rtracklayer transcript        NA\n          phase         gene_id   gene_name   transcript_id\n      &lt;integer&gt;     &lt;character&gt; &lt;character&gt;     &lt;character&gt;\n  [1]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000642480\n  [2]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000676397\n  [3]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000676319\n  [4]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000676189\n  [5]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000473257\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\n\n\n\n4.3.7.2 Split\nSeparately, the split() method is useful to divide a set of genomic ranges initially stored in a single GRanges object into groups that are stored in a named list of GRanges objects. Conveniently, the GRangesList class provides a container for efficiently displaying and processing lists of GRanges objects.\nIn the example below, we first extract the subset of entries that represent exons, before separating those exons by transcript identifier, yielding the result as a GRangesList object.\n\nactb_exons &lt;- subset(actb_gtf_data, type == \"exon\")\nactb_exons_by_transcript &lt;- split(actb_exons, actb_exons$transcript_id)\nactb_exons_by_transcript\n\nGRangesList object of length 23:\n$ENST00000414620\nGRanges object with 4 ranges and 7 metadata columns:\n      seqnames          ranges strand |      source     type     score\n         &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; |    &lt;factor&gt; &lt;factor&gt; &lt;numeric&gt;\n  [1]        7 5562574-5562790      - | rtracklayer     exon        NA\n  [2]        7 5540676-5540771      - | rtracklayer     exon        NA\n  [3]        7 5529535-5529663      - | rtracklayer     exon        NA\n  [4]        7 5529282-5529400      - | rtracklayer     exon        NA\n          phase         gene_id   gene_name   transcript_id\n      &lt;integer&gt;     &lt;character&gt; &lt;character&gt;     &lt;character&gt;\n  [1]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000414620\n  [2]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000414620\n  [3]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000414620\n  [4]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000414620\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\n$ENST00000417101\nGRanges object with 3 ranges and 7 metadata columns:\n      seqnames          ranges strand |      source     type     score\n         &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; |    &lt;factor&gt; &lt;factor&gt; &lt;numeric&gt;\n  [1]        7 5529806-5529982      - | rtracklayer     exon        NA\n  [2]        7 5529535-5529663      - | rtracklayer     exon        NA\n  [3]        7 5529235-5529400      - | rtracklayer     exon        NA\n          phase         gene_id   gene_name   transcript_id\n      &lt;integer&gt;     &lt;character&gt; &lt;character&gt;     &lt;character&gt;\n  [1]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000417101\n  [2]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000417101\n  [3]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000417101\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\n$ENST00000425660\nGRanges object with 7 ranges and 7 metadata columns:\n      seqnames          ranges strand |      source     type     score\n         &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; |    &lt;factor&gt; &lt;factor&gt; &lt;numeric&gt;\n  [1]        7 5530524-5530601      - | rtracklayer     exon        NA\n  [2]        7 5529535-5529663      - | rtracklayer     exon        NA\n  [3]        7 5529161-5529400      - | rtracklayer     exon        NA\n  [4]        7 5529019-5529059      - | rtracklayer     exon        NA\n  [5]        7 5528281-5528719      - | rtracklayer     exon        NA\n  [6]        7 5528004-5528185      - | rtracklayer     exon        NA\n  [7]        7 5527156-5527891      - | rtracklayer     exon        NA\n          phase         gene_id   gene_name   transcript_id\n      &lt;integer&gt;     &lt;character&gt; &lt;character&gt;     &lt;character&gt;\n  [1]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000425660\n  [2]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000425660\n  [3]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000425660\n  [4]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000425660\n  [5]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000425660\n  [6]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000425660\n  [7]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000425660\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\n...\n&lt;20 more elements&gt;\n\n\nWhen printing the object above in the console, the first line confirms the class of the object as GRrangesList, while each named GRanges in that list is introduced by the dollar sign and the name of that item, just like regular named lists in base R.\n\n\n4.3.7.3 Length\nBy nature, many of the methods applicable to list objects can be directly applied to GRangesList objects. For instance, the lengths() function can be used on GRangesList to display the length of each GRanges object in the list as an integer vector.\nIn the latest example above, we can compute the number of exons in each transcript as the length of each GRanges object within the GRangesList:\n\nlengths(actb_exons_by_transcript)\n\nENST00000414620 ENST00000417101 ENST00000425660 ENST00000432588 ENST00000443528 \n              4               3               7               5               3 \nENST00000462494 ENST00000464611 ENST00000473257 ENST00000477812 ENST00000480301 \n              5               3               5               5               2 \nENST00000484841 ENST00000493945 ENST00000642480 ENST00000645025 ENST00000645576 \n              5               6               5               4               5 \nENST00000646584 ENST00000646664 ENST00000647275 ENST00000674681 ENST00000675515 \n              2               6               3               6               6 \nENST00000676189 ENST00000676319 ENST00000676397 \n              6               3               6 \n\n\n\n\n\n\n\n\nPractice\n\n\n\nImportantly, the function lengths() (with a final s) demonstrated above is different from the function length() (without s). The former is meant to be used on list objects, while the latter is meant to be used on vectors.\nWhat does length(actb_exons_by_transcript) return, and why?\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\nlength(actb_exons_by_transcript)\n\n[1] 23\n\n\n\n\n\n\n\n\n\n\n4.3.8 Subset by overlap\nPossibly one of the most common operations when working with genomic ranges is to subset arbitrarily large collections of genomic ranges to those located in a specific region of the genome; for instance, when visualising information as tracks in a genome browser.\nTo demonstrate, we manually define a new GRanges representing a region of interest that we will use to extract all of the genomic ranges imported earlier from the GTF file which overlap that region of interest.\n\nregion_of_interest &lt;- GRanges(\n    seqnames = \"7\",\n    ranges = IRanges(start = 5525830, end = 5531239)\n)\n\nactb_in_region &lt;- subsetByOverlaps(x = actb_gtf_data, ranges = region_of_interest)\nactb_in_region\n\nGRanges object with 256 ranges and 7 metadata columns:\n        seqnames          ranges strand |      source           type     score\n           &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; |    &lt;factor&gt;       &lt;factor&gt; &lt;numeric&gt;\n    [1]        7 5526409-5563902      - | rtracklayer     gene              NA\n    [2]        7 5526409-5530601      - | rtracklayer     transcript        NA\n    [3]        7 5530542-5530601      - | rtracklayer     exon              NA\n    [4]        7 5529535-5529684      - | rtracklayer     exon              NA\n    [5]        7 5529535-5529657      - | rtracklayer     CDS               NA\n    ...      ...             ...    ... .         ...            ...       ...\n  [252]        7 5529535-5529657      - | rtracklayer CDS                   NA\n  [253]        7 5529655-5529657      - | rtracklayer start_codon           NA\n  [254]        7 5529282-5529400      - | rtracklayer exon                  NA\n  [255]        7 5529282-5529400      - | rtracklayer CDS                   NA\n  [256]        7 5529658-5529663      - | rtracklayer five_prime_utr        NA\n            phase         gene_id   gene_name   transcript_id\n        &lt;integer&gt;     &lt;character&gt; &lt;character&gt;     &lt;character&gt;\n    [1]      &lt;NA&gt; ENSG00000075624        ACTB            &lt;NA&gt;\n    [2]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000674681\n    [3]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000674681\n    [4]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000674681\n    [5]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000674681\n    ...       ...             ...         ...             ...\n  [252]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000414620\n  [253]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000414620\n  [254]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000414620\n  [255]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000414620\n  [256]      &lt;NA&gt; ENSG00000075624        ACTB ENST00000414620\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\n\nLike the subset() method, the subsetByOverlaps() method returns a new GRanges object. We can visually compare the information printed in the object (256 ranges in the new subsetted object, relative to 267 ranges in the original object), or we can programmatically compare the length of the two objects to check whether the new GRanges object is any smaller than the original GRanges object:\n\nlength(actb_in_region) - length(actb_gtf_data)\n\n[1] -11\n\n\nIn the example above, we learn that the new GRanges object has 11 records less than the original GRanges object."
  },
  {
    "objectID": "chapters/04_bioc.html#working-with-quantitative-data-the-summarizedexperiment-package",
    "href": "chapters/04_bioc.html#working-with-quantitative-data-the-summarizedexperiment-package",
    "title": "4  Analyzing biological data with the Bioconductor ecosystem",
    "section": "4.4 Working with quantitative data: the SummarizedExperiment package",
    "text": "4.4 Working with quantitative data: the SummarizedExperiment package\nThe figure below represents the anatomy of the SummarizedExperiment class.\n\n\n\n\n\nObjects of the class SummarizedExperiment contain :\n\nOne (or more) assay(s) containing the quantitative omics data (expression data), stored as a matrix-like object. Features (genes, transcripts, proteins, …) are defined along the rows, and samples along the columns.\nA sample metadata slot containing sample co-variates, stored as a data frame. Rows from this table represent samples (rows match exactly the columns of the expression data).\nA feature metadata slot containing feature co-variates, stored as a data frame. The rows of this data frame match exactly the rows of the expression data.\n\nThe coordinated nature of the SummarizedExperiment guarantees that during data manipulation, the dimensions of the different slots will always match (i.e the columns in the expression data and then rows in the sample metadata, as well as the rows in the expression data and feature metadata) during data manipulation. For example, if we had to exclude one sample from the assay, it would be automatically removed from the sample metadata in the same operation.\nThe metadata slots can grow additional co-variates (columns) without affecting the other structures.\n\n4.4.1 Creating a SummarizedExperiment object\nIn order to create a SummarizedExperiment, we will create the individual components, i.e the count matrix, the sample and gene metadata from csv files. These are typically how RNA-Seq data are provided (after raw data have been processed).\n\nAn expression matrix: we load the count matrix, specifying that the first columns contains row/gene names, and convert the data.frame to a matrix.\n\n\n# Read count matrix\ncount_matrix &lt;- read.csv(here(\"data\", \"count_matrix.csv\"), row.names = 1) |&gt;\n    as.matrix()\n\n# Inspect data\ncount_matrix[1:5, ]\n\n        GSM2545336 GSM2545337 GSM2545338 GSM2545339 GSM2545340 GSM2545341\nAsl           1170        361        400        586        626        988\nApod         36194      10347       9173      10620      13021      29594\nCyp2d22       4060       1616       1603       1901       2171       3349\nKlk6           287        629        641        578        448        195\nFcrls           85        233        244        237        180         38\n        GSM2545342 GSM2545343 GSM2545344 GSM2545345 GSM2545346 GSM2545347\nAsl            836        535        586        597        938       1035\nApod         24959      13668      13230      15868      27769      34301\nCyp2d22       3122       2008       2254       2277       2985       3452\nKlk6           186       1101        537        567        327        233\nFcrls           68        375        199        177         89         67\n        GSM2545348 GSM2545349 GSM2545350 GSM2545351 GSM2545352 GSM2545353\nAsl            494        481        666        937        803        541\nApod         11258      11812      15816      29242      20415      13682\nCyp2d22       1883       2014       2417       3678       2920       2216\nKlk6           742        881        828        250        798        710\nFcrls          300        233        231         81        303        285\n        GSM2545354 GSM2545362 GSM2545363 GSM2545380\nAsl            473        748        576       1192\nApod         11088      15916      11166      38148\nCyp2d22       1821       2842       2011       4019\nKlk6           894        501        598        259\nFcrls          248        179        184         68\n\ndim(count_matrix)\n\n[1] 1474   22\n\n\n\nA table describing the samples, often referred to as sample metadata.\n\n\n# Read sample metadata\nsample_metadata &lt;- read.csv(here(\"data\", \"sample_metadata.csv\"))\n\n# Inspect data\nsample_metadata\n\n       sample     organism age    sex   infection  strain time     tissue mouse\n1  GSM2545336 Mus musculus   8 Female  InfluenzaA C57BL/6    8 Cerebellum    14\n2  GSM2545337 Mus musculus   8 Female NonInfected C57BL/6    0 Cerebellum     9\n3  GSM2545338 Mus musculus   8 Female NonInfected C57BL/6    0 Cerebellum    10\n4  GSM2545339 Mus musculus   8 Female  InfluenzaA C57BL/6    4 Cerebellum    15\n5  GSM2545340 Mus musculus   8   Male  InfluenzaA C57BL/6    4 Cerebellum    18\n6  GSM2545341 Mus musculus   8   Male  InfluenzaA C57BL/6    8 Cerebellum     6\n7  GSM2545342 Mus musculus   8 Female  InfluenzaA C57BL/6    8 Cerebellum     5\n8  GSM2545343 Mus musculus   8   Male NonInfected C57BL/6    0 Cerebellum    11\n9  GSM2545344 Mus musculus   8 Female  InfluenzaA C57BL/6    4 Cerebellum    22\n10 GSM2545345 Mus musculus   8   Male  InfluenzaA C57BL/6    4 Cerebellum    13\n11 GSM2545346 Mus musculus   8   Male  InfluenzaA C57BL/6    8 Cerebellum    23\n12 GSM2545347 Mus musculus   8   Male  InfluenzaA C57BL/6    8 Cerebellum    24\n13 GSM2545348 Mus musculus   8 Female NonInfected C57BL/6    0 Cerebellum     8\n14 GSM2545349 Mus musculus   8   Male NonInfected C57BL/6    0 Cerebellum     7\n15 GSM2545350 Mus musculus   8   Male  InfluenzaA C57BL/6    4 Cerebellum     1\n16 GSM2545351 Mus musculus   8 Female  InfluenzaA C57BL/6    8 Cerebellum    16\n17 GSM2545352 Mus musculus   8 Female  InfluenzaA C57BL/6    4 Cerebellum    21\n18 GSM2545353 Mus musculus   8 Female NonInfected C57BL/6    0 Cerebellum     4\n19 GSM2545354 Mus musculus   8   Male NonInfected C57BL/6    0 Cerebellum     2\n20 GSM2545362 Mus musculus   8 Female  InfluenzaA C57BL/6    4 Cerebellum    20\n21 GSM2545363 Mus musculus   8   Male  InfluenzaA C57BL/6    4 Cerebellum    12\n22 GSM2545380 Mus musculus   8 Female  InfluenzaA C57BL/6    8 Cerebellum    19\n\ndim(sample_metadata)\n\n[1] 22  9\n\n\n\nA table describing the genes, often referred to as gene metadata.\n\n\n# Read gene metadata\ngene_metadata &lt;- read.csv(here(\"data\", \"gene_metadata.csv\"))\n\n# Inspect data\ngene_metadata[1:10, 1:4]\n\n      gene ENTREZID\n1      Asl   109900\n2     Apod    11815\n3  Cyp2d22    56448\n4     Klk6    19144\n5    Fcrls    80891\n6   Slc2a4    20528\n7     Exd2    97827\n8     Gjc2   118454\n9     Plp1    18823\n10    Gnb4    14696\n                                                                         product\n1                                 argininosuccinate lyase, transcript variant X1\n2                                         apolipoprotein D, transcript variant 3\n3   cytochrome P450, family 2, subfamily d, polypeptide 22, transcript variant 2\n4                           kallikrein related-peptidase 6, transcript variant 2\n5                  Fc receptor-like S, scavenger receptor, transcript variant X1\n6            solute carrier family 2 (facilitated glucose transporter), member 4\n7                                          exonuclease 3'-5' domain containing 2\n8                            gap junction protein, gamma 2, transcript variant 1\n9                           proteolipid protein (myelin) 1, transcript variant 1\n10 guanine nucleotide binding protein (G protein), beta 4, transcript variant X2\n      ensembl_gene_id\n1  ENSMUSG00000025533\n2  ENSMUSG00000022548\n3  ENSMUSG00000061740\n4  ENSMUSG00000050063\n5  ENSMUSG00000015852\n6  ENSMUSG00000018566\n7  ENSMUSG00000032705\n8  ENSMUSG00000043448\n9  ENSMUSG00000031425\n10 ENSMUSG00000027669\n\ndim(gene_metadata)\n\n[1] 1474    9\n\n\nWe will create a SummarizedExperiment from these tables:\n\nThe count matrix that will be used as the assay\nThe table describing the samples will be used as the colData slot\nThe table describing the genes will be used as the rowData slot\n\nTo do this we can put the different parts together using the SummarizedExperiment constructor:\n\n# Create SummarizedExperiment object\nse &lt;- SummarizedExperiment(\n    assays = list(counts = count_matrix),\n    colData = sample_metadata,\n    rowData = gene_metadata\n)\n\nse\n\nclass: SummarizedExperiment \ndim: 1474 22 \nmetadata(0):\nassays(1): counts\nrownames(1474): Asl Apod ... Lmx1a Pbx1\nrowData names(9): gene ENTREZID ... phenotype_description\n  hsapiens_homolog_associated_gene_name\ncolnames(22): GSM2545336 GSM2545337 ... GSM2545363 GSM2545380\ncolData names(9): sample organism ... tissue mouse\n\n\nUsing this data structure, we can access the expression matrix with the assay() function:\n\nhead(assay(se))\n\n        GSM2545336 GSM2545337 GSM2545338 GSM2545339 GSM2545340 GSM2545341\nAsl           1170        361        400        586        626        988\nApod         36194      10347       9173      10620      13021      29594\nCyp2d22       4060       1616       1603       1901       2171       3349\nKlk6           287        629        641        578        448        195\nFcrls           85        233        244        237        180         38\nSlc2a4         782        231        248        265        313        786\n        GSM2545342 GSM2545343 GSM2545344 GSM2545345 GSM2545346 GSM2545347\nAsl            836        535        586        597        938       1035\nApod         24959      13668      13230      15868      27769      34301\nCyp2d22       3122       2008       2254       2277       2985       3452\nKlk6           186       1101        537        567        327        233\nFcrls           68        375        199        177         89         67\nSlc2a4         528        249        266        357        654        693\n        GSM2545348 GSM2545349 GSM2545350 GSM2545351 GSM2545352 GSM2545353\nAsl            494        481        666        937        803        541\nApod         11258      11812      15816      29242      20415      13682\nCyp2d22       1883       2014       2417       3678       2920       2216\nKlk6           742        881        828        250        798        710\nFcrls          300        233        231         81        303        285\nSlc2a4         271        304        349        715        513        320\n        GSM2545354 GSM2545362 GSM2545363 GSM2545380\nAsl            473        748        576       1192\nApod         11088      15916      11166      38148\nCyp2d22       1821       2842       2011       4019\nKlk6           894        501        598        259\nFcrls          248        179        184         68\nSlc2a4         248        350        317        796\n\ndim(assay(se))\n\n[1] 1474   22\n\n\nWe can access the sample metadata using the colData() function:\n\ncolData(se)\n\nDataFrame with 22 rows and 9 columns\n                sample     organism       age         sex   infection\n           &lt;character&gt;  &lt;character&gt; &lt;integer&gt; &lt;character&gt; &lt;character&gt;\nGSM2545336  GSM2545336 Mus musculus         8      Female  InfluenzaA\nGSM2545337  GSM2545337 Mus musculus         8      Female NonInfected\nGSM2545338  GSM2545338 Mus musculus         8      Female NonInfected\nGSM2545339  GSM2545339 Mus musculus         8      Female  InfluenzaA\nGSM2545340  GSM2545340 Mus musculus         8        Male  InfluenzaA\n...                ...          ...       ...         ...         ...\nGSM2545353  GSM2545353 Mus musculus         8      Female NonInfected\nGSM2545354  GSM2545354 Mus musculus         8        Male NonInfected\nGSM2545362  GSM2545362 Mus musculus         8      Female  InfluenzaA\nGSM2545363  GSM2545363 Mus musculus         8        Male  InfluenzaA\nGSM2545380  GSM2545380 Mus musculus         8      Female  InfluenzaA\n                strain      time      tissue     mouse\n           &lt;character&gt; &lt;integer&gt; &lt;character&gt; &lt;integer&gt;\nGSM2545336     C57BL/6         8  Cerebellum        14\nGSM2545337     C57BL/6         0  Cerebellum         9\nGSM2545338     C57BL/6         0  Cerebellum        10\nGSM2545339     C57BL/6         4  Cerebellum        15\nGSM2545340     C57BL/6         4  Cerebellum        18\n...                ...       ...         ...       ...\nGSM2545353     C57BL/6         0  Cerebellum         4\nGSM2545354     C57BL/6         0  Cerebellum         2\nGSM2545362     C57BL/6         4  Cerebellum        20\nGSM2545363     C57BL/6         4  Cerebellum        12\nGSM2545380     C57BL/6         8  Cerebellum        19\n\ndim(colData(se))\n\n[1] 22  9\n\n\nWe can also access the feature metadata using the rowData() function:\n\nhead(rowData(se))\n\nDataFrame with 6 rows and 9 columns\n               gene  ENTREZID                product    ensembl_gene_id\n        &lt;character&gt; &lt;integer&gt;            &lt;character&gt;        &lt;character&gt;\nAsl             Asl    109900 argininosuccinate ly.. ENSMUSG00000025533\nApod           Apod     11815 apolipoprotein D, tr.. ENSMUSG00000022548\nCyp2d22     Cyp2d22     56448 cytochrome P450, fam.. ENSMUSG00000061740\nKlk6           Klk6     19144 kallikrein related-p.. ENSMUSG00000050063\nFcrls         Fcrls     80891 Fc receptor-like S, .. ENSMUSG00000015852\nSlc2a4       Slc2a4     20528 solute carrier famil.. ENSMUSG00000018566\n        external_synonym chromosome_name   gene_biotype  phenotype_description\n             &lt;character&gt;     &lt;character&gt;    &lt;character&gt;            &lt;character&gt;\nAsl        2510006M18Rik               5 protein_coding abnormal circulating..\nApod                  NA              16 protein_coding abnormal lipid homeo..\nCyp2d22             2D22              15 protein_coding abnormal skin morpho..\nKlk6                Bssp               7 protein_coding abnormal cytokine le..\nFcrls      2810439C17Rik               3 protein_coding decreased CD8-positi..\nSlc2a4            Glut-4              11 protein_coding abnormal circulating..\n        hsapiens_homolog_associated_gene_name\n                                  &lt;character&gt;\nAsl                                       ASL\nApod                                     APOD\nCyp2d22                                CYP2D6\nKlk6                                     KLK6\nFcrls                                   FCRL2\nSlc2a4                                 SLC2A4\n\ndim(rowData(se))\n\n[1] 1474    9\n\n\n\n\n4.4.2 Subsetting a SummarizedExperiment\nSummarizedExperiment objects can be subset just like with data frames, with numerics or with characters of logicals.\nBelow, we create a new instance of class SummarizedExperiment that contains only the 5 first features for the 3 first samples.\n\nse1 &lt;- se[1:5, 1:3]\nse1\n\nclass: SummarizedExperiment \ndim: 5 3 \nmetadata(0):\nassays(1): counts\nrownames(5): Asl Apod Cyp2d22 Klk6 Fcrls\nrowData names(9): gene ENTREZID ... phenotype_description\n  hsapiens_homolog_associated_gene_name\ncolnames(3): GSM2545336 GSM2545337 GSM2545338\ncolData names(9): sample organism ... tissue mouse\n\n\n\ncolData(se1)\n\nDataFrame with 3 rows and 9 columns\n                sample     organism       age         sex   infection\n           &lt;character&gt;  &lt;character&gt; &lt;integer&gt; &lt;character&gt; &lt;character&gt;\nGSM2545336  GSM2545336 Mus musculus         8      Female  InfluenzaA\nGSM2545337  GSM2545337 Mus musculus         8      Female NonInfected\nGSM2545338  GSM2545338 Mus musculus         8      Female NonInfected\n                strain      time      tissue     mouse\n           &lt;character&gt; &lt;integer&gt; &lt;character&gt; &lt;integer&gt;\nGSM2545336     C57BL/6         8  Cerebellum        14\nGSM2545337     C57BL/6         0  Cerebellum         9\nGSM2545338     C57BL/6         0  Cerebellum        10\n\nrowData(se1)\n\nDataFrame with 5 rows and 9 columns\n               gene  ENTREZID                product    ensembl_gene_id\n        &lt;character&gt; &lt;integer&gt;            &lt;character&gt;        &lt;character&gt;\nAsl             Asl    109900 argininosuccinate ly.. ENSMUSG00000025533\nApod           Apod     11815 apolipoprotein D, tr.. ENSMUSG00000022548\nCyp2d22     Cyp2d22     56448 cytochrome P450, fam.. ENSMUSG00000061740\nKlk6           Klk6     19144 kallikrein related-p.. ENSMUSG00000050063\nFcrls         Fcrls     80891 Fc receptor-like S, .. ENSMUSG00000015852\n        external_synonym chromosome_name   gene_biotype  phenotype_description\n             &lt;character&gt;     &lt;character&gt;    &lt;character&gt;            &lt;character&gt;\nAsl        2510006M18Rik               5 protein_coding abnormal circulating..\nApod                  NA              16 protein_coding abnormal lipid homeo..\nCyp2d22             2D22              15 protein_coding abnormal skin morpho..\nKlk6                Bssp               7 protein_coding abnormal cytokine le..\nFcrls      2810439C17Rik               3 protein_coding decreased CD8-positi..\n        hsapiens_homolog_associated_gene_name\n                                  &lt;character&gt;\nAsl                                       ASL\nApod                                     APOD\nCyp2d22                                CYP2D6\nKlk6                                     KLK6\nFcrls                                   FCRL2\n\n\nWe can also use the colData() function to subset on something from the sample metadata or the rowData() to subset on something from the feature metadata. For example, here we keep only miRNAs and the non infected samples:\n\n# Subset object\nse1 &lt;- se[rowData(se)$gene_biotype == \"miRNA\",\n          colData(se)$infection == \"NonInfected\"]\nse1\n\nclass: SummarizedExperiment \ndim: 7 7 \nmetadata(0):\nassays(1): counts\nrownames(7): Mir1901 Mir378a ... Mir128-1 Mir7682\nrowData names(9): gene ENTREZID ... phenotype_description\n  hsapiens_homolog_associated_gene_name\ncolnames(7): GSM2545337 GSM2545338 ... GSM2545353 GSM2545354\ncolData names(9): sample organism ... tissue mouse\n\nassay(se1)\n\n         GSM2545337 GSM2545338 GSM2545343 GSM2545348 GSM2545349 GSM2545353\nMir1901          45         44         74         55         68         33\nMir378a          11          7          9          4         12          4\nMir133b           4          6          5          4          6          7\nMir30c-2         10          6         16         12          8         17\nMir149            1          2          0          0          0          0\nMir128-1          4          1          2          2          1          2\nMir7682           2          0          4          1          3          5\n         GSM2545354\nMir1901          60\nMir378a           8\nMir133b           3\nMir30c-2         15\nMir149            2\nMir128-1          1\nMir7682           5\n\ncolData(se1)\n\nDataFrame with 7 rows and 9 columns\n                sample     organism       age         sex   infection\n           &lt;character&gt;  &lt;character&gt; &lt;integer&gt; &lt;character&gt; &lt;character&gt;\nGSM2545337  GSM2545337 Mus musculus         8      Female NonInfected\nGSM2545338  GSM2545338 Mus musculus         8      Female NonInfected\nGSM2545343  GSM2545343 Mus musculus         8        Male NonInfected\nGSM2545348  GSM2545348 Mus musculus         8      Female NonInfected\nGSM2545349  GSM2545349 Mus musculus         8        Male NonInfected\nGSM2545353  GSM2545353 Mus musculus         8      Female NonInfected\nGSM2545354  GSM2545354 Mus musculus         8        Male NonInfected\n                strain      time      tissue     mouse\n           &lt;character&gt; &lt;integer&gt; &lt;character&gt; &lt;integer&gt;\nGSM2545337     C57BL/6         0  Cerebellum         9\nGSM2545338     C57BL/6         0  Cerebellum        10\nGSM2545343     C57BL/6         0  Cerebellum        11\nGSM2545348     C57BL/6         0  Cerebellum         8\nGSM2545349     C57BL/6         0  Cerebellum         7\nGSM2545353     C57BL/6         0  Cerebellum         4\nGSM2545354     C57BL/6         0  Cerebellum         2\n\nrowData(se1)\n\nDataFrame with 7 rows and 9 columns\n                gene  ENTREZID        product    ensembl_gene_id\n         &lt;character&gt; &lt;integer&gt;    &lt;character&gt;        &lt;character&gt;\nMir1901      Mir1901 100316686  microRNA 1901 ENSMUSG00000084565\nMir378a      Mir378a    723889  microRNA 378a ENSMUSG00000105200\nMir133b      Mir133b    723817  microRNA 133b ENSMUSG00000065480\nMir30c-2    Mir30c-2    723964 microRNA 30c-2 ENSMUSG00000065567\nMir149        Mir149    387167   microRNA 149 ENSMUSG00000065470\nMir128-1    Mir128-1    387147 microRNA 128-1 ENSMUSG00000065520\nMir7682      Mir7682 102466847  microRNA 7682 ENSMUSG00000106406\n         external_synonym chromosome_name gene_biotype  phenotype_description\n              &lt;character&gt;     &lt;character&gt;  &lt;character&gt;            &lt;character&gt;\nMir1901          Mirn1901              18        miRNA                     NA\nMir378a           Mirn378              18        miRNA abnormal mitochondri..\nMir133b          mir 133b               1        miRNA no abnormal phenotyp..\nMir30c-2        mir 30c-2               1        miRNA                     NA\nMir149            Mirn149               1        miRNA increased circulatin..\nMir128-1          Mirn128               1        miRNA no abnormal phenotyp..\nMir7682      mmu-mir-7682               1        miRNA                     NA\n         hsapiens_homolog_associated_gene_name\n                                   &lt;character&gt;\nMir1901                                     NA\nMir378a                                MIR378A\nMir133b                                MIR133B\nMir30c-2                               MIR30C2\nMir149                                      NA\nMir128-1                              MIR128-1\nMir7682                                     NA\n\n\n\n\n\n\n\n\nPractice\n\n\n\n\nExtract the gene expression levels of the 3 first genes in samples at time 0 and at time 8.\n\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\nassay(se)[1:3, colData(se)$time != 4]\n\n        GSM2545336 GSM2545337 GSM2545338 GSM2545341 GSM2545342 GSM2545343\nAsl           1170        361        400        988        836        535\nApod         36194      10347       9173      29594      24959      13668\nCyp2d22       4060       1616       1603       3349       3122       2008\n        GSM2545346 GSM2545347 GSM2545348 GSM2545349 GSM2545351 GSM2545353\nAsl            938       1035        494        481        937        541\nApod         27769      34301      11258      11812      29242      13682\nCyp2d22       2985       3452       1883       2014       3678       2216\n        GSM2545354 GSM2545380\nAsl            473       1192\nApod         11088      38148\nCyp2d22       1821       4019\n\n# Equivalent to\nassay(se)[1:3, colData(se)$time == 0 | colData(se)$time == 8]\n\n        GSM2545336 GSM2545337 GSM2545338 GSM2545341 GSM2545342 GSM2545343\nAsl           1170        361        400        988        836        535\nApod         36194      10347       9173      29594      24959      13668\nCyp2d22       4060       1616       1603       3349       3122       2008\n        GSM2545346 GSM2545347 GSM2545348 GSM2545349 GSM2545351 GSM2545353\nAsl            938       1035        494        481        937        541\nApod         27769      34301      11258      11812      29242      13682\nCyp2d22       2985       3452       1883       2014       3678       2216\n        GSM2545354 GSM2545380\nAsl            473       1192\nApod         11088      38148\nCyp2d22       1821       4019\n\n\n\n\n\n\n\n\n\n4.4.3 Saving data\nExporting data to a spreadsheet, as we did in a previous lesson, has several limitations, such as those described in the first chapter (possible inconsistencies with , and . for decimal separators and lack of variable type definitions). Furthermore, exporting data to a spreadsheet is only relevant for rectangular data such as dataframes and matrices.\nA more general way to save data, that is specific to R and is guaranteed to work on any operating system, is to use the saveRDS() function. Saving objects like this will generate a binary representation on disk (using the rds file extension here), which can be loaded back into R using the readRDS function.\n\n# Save R object as an RDS file\nsaveRDS(se, file = here(\"output\", \"se.rds\"))\nrm(se)\n\nse &lt;- readRDS(here(\"output\", \"se.rds\"))\nhead(se)\n\nclass: SummarizedExperiment \ndim: 6 22 \nmetadata(0):\nassays(1): counts\nrownames(6): Asl Apod ... Fcrls Slc2a4\nrowData names(9): gene ENTREZID ... phenotype_description\n  hsapiens_homolog_associated_gene_name\ncolnames(22): GSM2545336 GSM2545337 ... GSM2545363 GSM2545380\ncolData names(9): sample organism ... tissue mouse\n\n\nTo conclude, when it comes to saving data from R that will be loaded again in R, saving and loading with saveRDS and readRDS is the preferred approach. If tabular data need to be shared with somebody that is not using R, then exporting to a text-based spreadsheet is a good alternative."
  }
]