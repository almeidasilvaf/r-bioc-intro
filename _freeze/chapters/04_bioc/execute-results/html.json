{
  "hash": "68cc3f4ab3c7c09db8bb1cf7487591d9",
  "result": {
    "markdown": "---\nexecute: \n  warning: false\n---\n\n\n# Analyzing biological data with the Bioconductor ecosystem\n\n[The Bioconductor project](https://bioconductor.org/) was created to develop,\nsupport, and disseminate free open source software to analyze biological data.\nIt works as a repository of R packages for biological data analysis, with\nboth \"core packages\" (developed and maintained by the Bioconductor Core Team),\nand community-contributed packages. We usually refer to Bioconductor as a\n\"package ecosystem\" because its packages are tightly integrated and designed\nfor easy interoperation, such that different packages can be used together\nwith minimal effort. An important facilitator of such interoperability is\nthe existence of standardized data structures, such as `GRanges` objects\nfor genomic coordinates, `DNA/RNA/AAStringSet` objects for sequences,\nand `SummarizedExperiment` objects for quantitative data.\n\n\nLet's start by loading the required packages and data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(Biostrings)\nlibrary(GenomicRanges)\nlibrary(SummarizedExperiment)\nlibrary(tidyverse)\nlibrary(here)\n```\n:::\n\n\n## Goals of this lesson\n\nAt the end of this lesson, you will be able to:\n\n- read and process sequence data with **`Biostrings`**\n- read and process genomic coordinates with **`GenomicRanges`**\n- read and process quantitative data (e.g., gene expression) \nwith **`SummarizedExperiment`**\n\n## Working with sequences: the **`Biostrings`** package\n\nThe **`Biostrings`** package allows efficient manipulation of \nbiological sequences, and its data classes are standard for all Bioconductor\npackages that involve sequence analyses. The data classes in Biostrings to\nrepresent sets of biological sequences are:\n\n1. `DNAStringSet`: for sets of DNA strings.\n2. `RNAStringSet`: for sets of RNA strings.\n3. `AAStringSet`: for sets of amino acid strings.\n\nFor a single sequence, the each of the above has a correspoding `XString` class\n(i.e., `DNAString`, `RNAString`, `AAString`). For example, let's create some\n`XString` objects manually:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create `DNAString` object\ndna_seq <- DNAString(\"ATGGCCGACTCA\")\ndna_seq\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n12-letter DNAString object\nseq: ATGGCCGACTCA\n```\n:::\n\n```{.r .cell-code}\n# Convert `DNAString` to `RNAString`\nrna_seq <- RNAString(dna_seq)\nrna_seq\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n12-letter RNAString object\nseq: AUGGCCGACUCA\n```\n:::\n\n```{.r .cell-code}\n# Translate `RNAString` to create `AAString`\naa_seq <- translate(rna_seq)\naa_seq\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4-letter AAString object\nseq: MADS\n```\n:::\n:::\n\n\nIn real-world data analyses, we would work with multiple sequences (e.g., \na whole genome or a whole proteome). Multiple sequences are stored \nin `XStringSet` objects, which can be read from FASTA files \nwith `readXStringSet()` functions, namely:\n\n1. `readDNAStringSet()`: read FASTA file containing multiple DNA sequences.\n2. `readRNAStringSet()`: read FASTA file containing multiple RNA sequences. \n3. `readAAStringSet()`: read FASTA file containing multiple AA sequences.\n\nFor example, let's read an example FASTA file that come with the Biostrings\npackage.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Path to FASTA file containing an ORF\nfasta_file <- system.file(\"extdata\", \"someORF.fa\", package = \"Biostrings\")\nfasta_file\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"/home/faalm/R/x86_64-pc-linux-gnu-library/4.3/Biostrings/extdata/someORF.fa\"\n```\n:::\n\n```{.r .cell-code}\n# Read FASTA file as a DNAStringSet object\ndna_seqs <- readDNAStringSet(fasta_file)\ndna_seqs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDNAStringSet object of length 7:\n    width seq                                               names               \n[1]  5573 ACTTGTAAATATATCTTTTATTT...CTTATCGACCTTATTGTTGATAT YAL001C TFC3 SGDI...\n[2]  5825 TTCCAAGGCCGATGAATTCGACT...AGTAAATTTTTTTCTATTCTCTT YAL002W VPS8 SGDI...\n[3]  2987 CTTCATGTCAGCCTGCACTTCTG...TGGTACTCATGTAGCTGCCTCAT YAL003W EFB1 SGDI...\n[4]  3929 CACTCATATCGGGGGTCTTACTT...TGTCCCGAAACACGAAAAAGTAC YAL005C SSA1 SGDI...\n[5]  2648 AGAGAAAGAGTTTCACTTCTTGA...ATATAATTTATGTGTGAACATAG YAL007C ERP2 SGDI...\n[6]  2597 GTGTCCGGGCCTCGCAGGCGTTC...AAGTTTTGGCAGAATGTACTTTT YAL008W FUN14 SGD...\n[7]  2780 CAAGATAATGTCAAAGTTAGTGG...GCTAAGGAAGAAAAAAAAATCAC YAL009W SPO7 SGDI...\n```\n:::\n:::\n\n\nSome examples of what you can do to explore `XStringSet` objects include:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# width(): get sequence lengths\nwidth(dna_seqs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5573 5825 2987 3929 2648 2597 2780\n```\n:::\n\n```{.r .cell-code}\n# names(): get sequence names\nnames(dna_seqs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"YAL001C TFC3 SGDID:S0000001, Chr I from 152168-146596, reverse complement, Verified ORF\"\n[2] \"YAL002W VPS8 SGDID:S0000002, Chr I from 142709-148533, Verified ORF\"                    \n[3] \"YAL003W EFB1 SGDID:S0000003, Chr I from 141176-144162, Verified ORF\"                    \n[4] \"YAL005C SSA1 SGDID:S0000004, Chr I from 142433-138505, reverse complement, Verified ORF\"\n[5] \"YAL007C ERP2 SGDID:S0000005, Chr I from 139347-136700, reverse complement, Verified ORF\"\n[6] \"YAL008W FUN14 SGDID:S0000006, Chr I from 135916-138512, Verified ORF\"                   \n[7] \"YAL009W SPO7 SGDID:S0000007, Chr I from 134856-137635, Verified ORF\"                    \n```\n:::\n\n```{.r .cell-code}\n# subset DNAStringSet and create a DNAStringSet of length 1\ndna_seqs[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDNAStringSet object of length 1:\n    width seq                                               names               \n[1]  5573 ACTTGTAAATATATCTTTTATTT...CTTATCGACCTTATTGTTGATAT YAL001C TFC3 SGDI...\n```\n:::\n\n```{.r .cell-code}\n# subset DNAStringSet and create a DNAString object\ndna_seqs[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5573-letter DNAString object\nseq: ACTTGTAAATATATCTTTTATTTTCCGAGAGGAAAA...AATTTCTTAAACGCTTATCGACCTTATTGTTGATAT\n```\n:::\n:::\n\n\nAll functions above would also work for `AAStringSet` objects \nand `RNAStringSet` objects.\n\n\n::: {.callout-tip}\n\n### Practice\n\nUse the `dna_seqs` object created above to answer the following questions:\n\n1. What is the length of the 3rd sequence?\n2. What is the name of the 5th sequence?\n3. How many times does the **TTCC** sequence string occur in each sequence?\nHint: use the function `vcountPattern()`.\n4. What are the first 3 nucleotides of each sequence? \nHint: use the `subseq()` function.\n\n::: {.callout collapse=\"true\" appearance=\"minimal\"}\n\n### Show me the solutions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Q1: Length of the 3rd sequence\nwidth(dna_seqs)[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2987\n```\n:::\n\n```{.r .cell-code}\n# Q2: Name of the 5th sequence\nnames(dna_seqs)[5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"YAL007C ERP2 SGDID:S0000005, Chr I from 139347-136700, reverse complement, Verified ORF\"\n```\n:::\n\n```{.r .cell-code}\n# Q3: Minimum and maximum temperature\nvcountPattern(\"TTCC\", dna_seqs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21 28 16 23 15  8  5\n```\n:::\n\n```{.r .cell-code}\n# Q4: First 3 nucleotides of each sequence\nsubseq(dna_seqs, start = 1, end = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDNAStringSet object of length 7:\n    width seq                                               names               \n[1]     3 ACT                                               YAL001C TFC3 SGDI...\n[2]     3 TTC                                               YAL002W VPS8 SGDI...\n[3]     3 CTT                                               YAL003W EFB1 SGDI...\n[4]     3 CAC                                               YAL005C SSA1 SGDI...\n[5]     3 AGA                                               YAL007C ERP2 SGDI...\n[6]     3 GTG                                               YAL008W FUN14 SGD...\n[7]     3 CAA                                               YAL009W SPO7 SGDI...\n```\n:::\n:::\n\n\n:::\n:::\n\n## Working with genomic ranges: the **`GenomicRanges`** package\n\nThe **`GenomicRanges`** package implements S4 classes \nto represent genomic ranges as S4 objects. \n\nSpecifically, the `GRanges` class is designed to store a set of intervals\nincluding the name of the sequence where features are located as well as the\nrange of integer coordinates spanned by the feature in that sequence.\n\nMore generally, the `IRanges` class is designed to store a set of intervals\nover a range of integer coordinates, without the notion of sequence names.\nAs such, a `GRanges` object is merely the combination of an `IRanges` object and\na vector of sequence names.\n\nThose S4 classes provide automatic validity-checking functionality,\nand a range of methods implementing common operations on integer intervals\nand genomic ranges,\nfrom the calculation of distance between pairs of intervals to the\nidentification of overlapping genomic ranges.\n\n### The `IRanges` class\n\nWhile the genomic space of many organisms is subdivided into multiple sequences\n(e.g., chromosomes), many operations on genomic ranges take place within\nindividual sequences, where only integer positions matter.\nThe `IRanges` class provides a container for such \"simple\" ranges that are\ndefined by two out of three pieces of information:\n\n- the start position of the range\n- the width of the range\n- the end position of the range\n\nThe `IRanges()` constructor function accepts those three pieces of information\nin the arguments `start=`, `width=`, and `end=`.\nFor instance, we create two integer ranges from their start position and width:\n\n- one range starts at position 10 and has width 10\n- one range starts at position 15 and has width 5\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo_iranges <- IRanges(start = c(10, 15), width = c(10, 5))\ndemo_iranges\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIRanges object with 2 ranges and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]        10        19        10\n  [2]        15        19         5\n```\n:::\n:::\n\n\nWe note how the object displays not only the *start* and *width* information\nthat we requested for each range, but also the *end* position that is naturally\ncomputed from the other two pieces of information.\n\n::: {.callout-tip}\n\n### Practice\n\nCreate the same two ranges as above, using the arguments `start=` and `end=`\nof the `IRanges()` constructor function.\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nIRanges(start = c(10, 15), end = c(19, 19))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIRanges object with 2 ranges and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]        10        19        10\n  [2]        15        19         5\n```\n:::\n:::\n\n\n:::\n:::\n\nThe start and end positions as well as the width of every interval can be\nextracted as numeric vector using the functions `start()`, `end()` and\n`width()`, respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart(demo_iranges)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 15\n```\n:::\n\n```{.r .cell-code}\nend(demo_iranges)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19 19\n```\n:::\n\n```{.r .cell-code}\nwidth(demo_iranges)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10  5\n```\n:::\n:::\n\n\nObjects of the `IRanges` family extend the `Vector` class, and are handled as\nunidimensional vectors in terms of indexing.\nAs such, individual ranges can be extracted by integer index like any\nregular vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo_iranges[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIRanges object with 1 range and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]        10        19        10\n```\n:::\n:::\n\n\n### Metadata on `IRanges`\n\nThe `IRanges` class can accommodate metadata information on each range,\nincluding names - passed to the `names=` argument - and miscellaneous metadata\npassed as named vectors.\n\nFor instance, we create two ranges named \"A\" and \"B\".\nFurthermore, we define metadata fields to store an example of character\nvalues and numeric values, respectively.\nBoth the names and the values of the metadata fields are completely arbitrary\nin this example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo_with_metadata <- IRanges(\n    start = c(10,  15),\n    end   = c(19,  19),\n    names = c(\"A\", \"B\"),\n    character_metadata = c(\"control\", \"target\"),\n    numeric_metadata = c(100, 200)\n)\n\ndemo_with_metadata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIRanges object with 2 ranges and 2 metadata columns:\n        start       end     width | character_metadata numeric_metadata\n    <integer> <integer> <integer> |        <character>        <numeric>\n  A        10        19        10 |            control              100\n  B        15        19         5 |             target              200\n```\n:::\n:::\n\n\nThe metadata columns can be extracted as a `DataFrame` using the \nfunction `mcols()` (short for \"metadata columns\").\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcols(demo_with_metadata)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 2 rows and 2 columns\n  character_metadata numeric_metadata\n         <character>        <numeric>\nA            control              100\nB             target              200\n```\n:::\n:::\n\n\nThe character vector of names can be extracted using the function `names()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(demo_with_metadata)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A\" \"B\"\n```\n:::\n:::\n\n\nSimilarly to named vector of base data types, individual ranges can be extracted\nby name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo_with_metadata[\"A\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIRanges object with 1 range and 2 metadata columns:\n        start       end     width | character_metadata numeric_metadata\n    <integer> <integer> <integer> |        <character>        <numeric>\n  A        10        19        10 |            control              100\n```\n:::\n:::\n\n\n### The `GRanges` class\n\nHaving defined integer ranges, the only additional information necessary to\ndefine genomic ranges is the name of the genomic sequence on which each range is\nlocated.\n\nFor instance, we define two genomic ranges, as follows:\n\n- one genomic range on chromosome 1 (abbreviated \"chr1\"), from position 10 to 25\n- one genomic range on chromosome 2 (abbreviated \"chr2\"), from position 20 to 35\n\nTo do so, we use the `GRanges()` constructor function.\nWe provide the sequence names as a character vector to the argument `seqnames=`,\nand we provide both the start and end position to the argument `ranges=`\nas an `IRanges` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo_granges <- GRanges(\n    seqnames = c(\"chr1\", \"chr2\"),\n    ranges = IRanges(\n        start = c(10, 20),\n        end   = c(25, 35))\n)\n\ndemo_granges\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGRanges object with 2 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]     chr1     10-25      *\n  [2]     chr2     20-35      *\n  -------\n  seqinfo: 2 sequences from an unspecified genome; no seqlengths\n```\n:::\n:::\n\n\nIn the console, the object displays the sequence names in the `seqnames`\ncomponent, and the ranges in the form `start-end` in the `ranges` component.\nFurthermore, the example above also demonstrate that `GRanges` objects possess a\ncomponent called `strand`; the symbol `*` indicates unstranded genomic ranges,\nas we have not provided that information.\n\nThe strand information can be supplied to the `strand=` argument, for instance:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo_granges2 <- GRanges(\n    seqnames = c(\"chr1\", \"chr2\"),\n    ranges = IRanges(\n        start = c(10, 20),\n        end   = c(25, 35)),\n    strand  = c(\"+\", \"-\")\n)\n\ndemo_granges2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGRanges object with 2 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]     chr1     10-25      +\n  [2]     chr2     20-35      -\n  -------\n  seqinfo: 2 sequences from an unspecified genome; no seqlengths\n```\n:::\n:::\n\n\nFinally, the examples above also demonstrate that `GRanges` objects include a\ncomponent called `seqinfo`, which is occasionally used to store information\nabout each sequence that may be represented in the `seqnames` component.\nIn the latest example above, we have not provide any information about any\nsequence.\nAs such, the `seqinfo` component was automatically populated with the names\nof the sequences that we used to create the object, while the remaining\npieces of information were left unspecified, as `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseqinfo(demo_granges2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSeqinfo object with 2 sequences from an unspecified genome; no seqlengths:\n  seqnames seqlengths isCircular genome\n  chr1             NA         NA   <NA>\n  chr2             NA         NA   <NA>\n```\n:::\n:::\n\n\nThe example above reveals that information about sequences include not only\ntheir respective name and length, but also whether they represent a circular\npolymer (e.g., plasmid), and the name of the genome that they are part of.\n\n### Metadata on `GRanges`\n\nSimilarly to `IRanges`, metadata can be passed directly to the `GRanges`\nconstructor function.\nFor instance:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo_granges3 <- GRanges(\n    seqnames = c(\"chr1\", \"chr2\"),\n    ranges = IRanges(\n        start = c(10, 20),\n        end = c(25, 35)),\n    metadata1 = c(\"control\", \"target\"),\n    metadata2 = c(1, 2)\n)\n\ndemo_granges3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGRanges object with 2 ranges and 2 metadata columns:\n      seqnames    ranges strand |   metadata1 metadata2\n         <Rle> <IRanges>  <Rle> | <character> <numeric>\n  [1]     chr1     10-25      * |     control         1\n  [2]     chr2     20-35      * |      target         2\n  -------\n  seqinfo: 2 sequences from an unspecified genome; no seqlengths\n```\n:::\n:::\n\n\n### Importing genomic ranges from files\n\nFrequently, large collections of genomic ranges are imported from files rather\nthan described in manually written code.\nIn particular, genome-wide annotations of known gene features are distributed\nas files on websites such as \n[Ensembl](https://www.ensembl.org/info/data/index.html).\n\nVarious file formats are commonly used to store genomic ranges in bioinformatics\nworkflows.\nFor instance, the BED (Browser Extensible Data) format is commonly found in\nChromatin Immunoprecipitation Sequencing (ChIP-Seq), while GTF\n(Gene Transfer Format, GTF2.2) is the *de facto* standard file format to\ndescribe genomic features such as exons, transcripts, and genes.\n\nIn the following example, we import the gene model for Actin Beta (ACTB) from\na small GTF file as a set of genomic ranges.\nThe example file represents a subset of a GTF file for the *Homo sapiens*\nspecies, downloaded from \n[Ensembl](https://www.ensembl.org/info/data/index.html).\nThe original file contains more than 3 millions lines and 22 metadata fields,\nfrom which a subset was extracted into a smaller file for this lesson.\n\nIn particular, we use the `import()` generic\ndefined in the *[BiocIO](https://bioconductor.org/packages/3.17/BiocIO)* package - with methods\nimplemented in the *[rtracklayer](https://bioconductor.org/packages/3.17/rtracklayer)* package - as a\nversatile function that is capable of recognising common file extensions and\nassociating them with the appropriate method for parsing each particular file\nformat.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rtracklayer)\n\nactb_gtf_data <- rtracklayer::import(here(\"data\", \"actb.gtf\"))\nactb_gtf_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGRanges object with 267 ranges and 7 metadata columns:\n        seqnames          ranges strand |      source           type     score\n           <Rle>       <IRanges>  <Rle> |    <factor>       <factor> <numeric>\n    [1]        7 5526409-5563902      - | rtracklayer     gene              NA\n    [2]        7 5526409-5530601      - | rtracklayer     transcript        NA\n    [3]        7 5530542-5530601      - | rtracklayer     exon              NA\n    [4]        7 5529535-5529684      - | rtracklayer     exon              NA\n    [5]        7 5529535-5529657      - | rtracklayer     CDS               NA\n    ...      ...             ...    ... .         ...            ...       ...\n  [263]        7 5540676-5540771      - | rtracklayer five_prime_utr        NA\n  [264]        7 5529658-5529663      - | rtracklayer five_prime_utr        NA\n  [265]        7 5561852-5562716      - | rtracklayer transcript            NA\n  [266]        7 5562390-5562716      - | rtracklayer exon                  NA\n  [267]        7 5561852-5561949      - | rtracklayer exon                  NA\n            phase         gene_id   gene_name   transcript_id\n        <integer>     <character> <character>     <character>\n    [1]      <NA> ENSG00000075624        ACTB            <NA>\n    [2]      <NA> ENSG00000075624        ACTB ENST00000674681\n    [3]      <NA> ENSG00000075624        ACTB ENST00000674681\n    [4]      <NA> ENSG00000075624        ACTB ENST00000674681\n    [5]      <NA> ENSG00000075624        ACTB ENST00000674681\n    ...       ...             ...         ...             ...\n  [263]      <NA> ENSG00000075624        ACTB ENST00000414620\n  [264]      <NA> ENSG00000075624        ACTB ENST00000414620\n  [265]      <NA> ENSG00000075624        ACTB ENST00000646584\n  [266]      <NA> ENSG00000075624        ACTB ENST00000646584\n  [267]      <NA> ENSG00000075624        ACTB ENST00000646584\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n```\n:::\n:::\n\n\nIn the example above, the contents of the GTF file were imported into a\n`GRanges` object. For each entry in the file, the sequence name, start and end\nposition, and strand information were used to populate the dedicated components\nof the object, while all other pieces of information are stored as separate\ncolumns of metadata.\n\nFrom here on, this `GRanges` object can be manipulated just like any of the\nother `GRanges` objects that we have created earlier in this episode.\n\n### Operations on `GRanges` and the `GRangesList` class\n\nAs we have demonstrated so far, `GRanges` objects can be manually defined\nor imported from files.\nThose often represent genomic regions of interest, and databases of known\ngenomic features, respectively.\nEither way, a number of operations are commonly applied to `GRanges` objects\nthroughout bioinformatics workflows.\n\n#### Subset\n\nFor instance, the `subset()` method is extremely convenient to extract a set\nof genomic ranges matching a condition on any component, including sequence\nname, start and end position, strand, or any metadata field.\nIn the example below, we extract all the records of type `transcript` that start\nat position `5527147`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset(actb_gtf_data, type == \"transcript\" & start == 5527147)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGRanges object with 5 ranges and 7 metadata columns:\n      seqnames          ranges strand |      source       type     score\n         <Rle>       <IRanges>  <Rle> |    <factor>   <factor> <numeric>\n  [1]        7 5527147-5529949      - | rtracklayer transcript        NA\n  [2]        7 5527147-5530581      - | rtracklayer transcript        NA\n  [3]        7 5527147-5530604      - | rtracklayer transcript        NA\n  [4]        7 5527147-5530604      - | rtracklayer transcript        NA\n  [5]        7 5527147-5530604      - | rtracklayer transcript        NA\n          phase         gene_id   gene_name   transcript_id\n      <integer>     <character> <character>     <character>\n  [1]      <NA> ENSG00000075624        ACTB ENST00000642480\n  [2]      <NA> ENSG00000075624        ACTB ENST00000676397\n  [3]      <NA> ENSG00000075624        ACTB ENST00000676319\n  [4]      <NA> ENSG00000075624        ACTB ENST00000676189\n  [5]      <NA> ENSG00000075624        ACTB ENST00000473257\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n```\n:::\n:::\n\n\n#### Split\n\nSeparately, the `split()` method is useful to divide a set of genomic ranges\ninitially stored in a single `GRanges` object into groups that are stored\nin a named list of `GRanges` objects.\nConveniently, the `GRangesList` class provides a container for efficiently\ndisplaying and processing lists of `GRanges` objects.\n\nIn the example below, we first extract the subset of entries that represent\nexons, before separating those exons by transcript identifier, yielding\nthe result as a `GRangesList` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nactb_exons <- subset(actb_gtf_data, type == \"exon\")\nactb_exons_by_transcript <- split(actb_exons, actb_exons$transcript_id)\nactb_exons_by_transcript\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGRangesList object of length 23:\n$ENST00000414620\nGRanges object with 4 ranges and 7 metadata columns:\n      seqnames          ranges strand |      source     type     score\n         <Rle>       <IRanges>  <Rle> |    <factor> <factor> <numeric>\n  [1]        7 5562574-5562790      - | rtracklayer     exon        NA\n  [2]        7 5540676-5540771      - | rtracklayer     exon        NA\n  [3]        7 5529535-5529663      - | rtracklayer     exon        NA\n  [4]        7 5529282-5529400      - | rtracklayer     exon        NA\n          phase         gene_id   gene_name   transcript_id\n      <integer>     <character> <character>     <character>\n  [1]      <NA> ENSG00000075624        ACTB ENST00000414620\n  [2]      <NA> ENSG00000075624        ACTB ENST00000414620\n  [3]      <NA> ENSG00000075624        ACTB ENST00000414620\n  [4]      <NA> ENSG00000075624        ACTB ENST00000414620\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\n$ENST00000417101\nGRanges object with 3 ranges and 7 metadata columns:\n      seqnames          ranges strand |      source     type     score\n         <Rle>       <IRanges>  <Rle> |    <factor> <factor> <numeric>\n  [1]        7 5529806-5529982      - | rtracklayer     exon        NA\n  [2]        7 5529535-5529663      - | rtracklayer     exon        NA\n  [3]        7 5529235-5529400      - | rtracklayer     exon        NA\n          phase         gene_id   gene_name   transcript_id\n      <integer>     <character> <character>     <character>\n  [1]      <NA> ENSG00000075624        ACTB ENST00000417101\n  [2]      <NA> ENSG00000075624        ACTB ENST00000417101\n  [3]      <NA> ENSG00000075624        ACTB ENST00000417101\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\n$ENST00000425660\nGRanges object with 7 ranges and 7 metadata columns:\n      seqnames          ranges strand |      source     type     score\n         <Rle>       <IRanges>  <Rle> |    <factor> <factor> <numeric>\n  [1]        7 5530524-5530601      - | rtracklayer     exon        NA\n  [2]        7 5529535-5529663      - | rtracklayer     exon        NA\n  [3]        7 5529161-5529400      - | rtracklayer     exon        NA\n  [4]        7 5529019-5529059      - | rtracklayer     exon        NA\n  [5]        7 5528281-5528719      - | rtracklayer     exon        NA\n  [6]        7 5528004-5528185      - | rtracklayer     exon        NA\n  [7]        7 5527156-5527891      - | rtracklayer     exon        NA\n          phase         gene_id   gene_name   transcript_id\n      <integer>     <character> <character>     <character>\n  [1]      <NA> ENSG00000075624        ACTB ENST00000425660\n  [2]      <NA> ENSG00000075624        ACTB ENST00000425660\n  [3]      <NA> ENSG00000075624        ACTB ENST00000425660\n  [4]      <NA> ENSG00000075624        ACTB ENST00000425660\n  [5]      <NA> ENSG00000075624        ACTB ENST00000425660\n  [6]      <NA> ENSG00000075624        ACTB ENST00000425660\n  [7]      <NA> ENSG00000075624        ACTB ENST00000425660\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\n...\n<20 more elements>\n```\n:::\n:::\n\n\nWhen printing the object above in the console, the first line confirms the\nclass of the object as `GRrangesList`, while each named `GRanges` in that list\nis introduced by the dollar sign and the name of that item, just like regular\nnamed lists in base R.\n\n#### Length\n\nBy nature, many of the methods applicable to `list` objects can be directly\napplied to `GRangesList` objects.\nFor instance, the `lengths()` function can be used on `GRangesList` to display\nthe length of each `GRanges` object in the list as an integer vector.\n\nIn the latest example above, we can compute the number of exons in each transcript\nas the length of each `GRanges` object within the `GRangesList`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlengths(actb_exons_by_transcript)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nENST00000414620 ENST00000417101 ENST00000425660 ENST00000432588 ENST00000443528 \n              4               3               7               5               3 \nENST00000462494 ENST00000464611 ENST00000473257 ENST00000477812 ENST00000480301 \n              5               3               5               5               2 \nENST00000484841 ENST00000493945 ENST00000642480 ENST00000645025 ENST00000645576 \n              5               6               5               4               5 \nENST00000646584 ENST00000646664 ENST00000647275 ENST00000674681 ENST00000675515 \n              2               6               3               6               6 \nENST00000676189 ENST00000676319 ENST00000676397 \n              6               3               6 \n```\n:::\n:::\n\n\n::: {.callout-tip}\n\n### Practice\n\nImportantly, the function `lengths()` (with a final `s`) demonstrated above\nis different from the function `length()` (without `s`).\nThe former is meant to be used on list objects, while the latter is meant\nto be used on vectors.\n\nWhat does `length(actb_exons_by_transcript)` return, and why?\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(actb_exons_by_transcript)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 23\n```\n:::\n:::\n\n\n:::\n:::\n\n### Subset by overlap\n\nPossibly one of the most common operations when working with genomic ranges\nis to subset arbitrarily large collections of genomic ranges to those located\nin a specific region of the genome; for instance, when visualising information\nas tracks in a genome browser.\n\nTo demonstrate, we manually define a new `GRanges` representing a region of\ninterest that we will use to extract all of the genomic ranges imported earlier\nfrom the GTF file which overlap that region of interest.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregion_of_interest <- GRanges(\n    seqnames = \"7\",\n    ranges = IRanges(start = 5525830, end = 5531239)\n)\n\nactb_in_region <- subsetByOverlaps(x = actb_gtf_data, ranges = region_of_interest)\nactb_in_region\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGRanges object with 256 ranges and 7 metadata columns:\n        seqnames          ranges strand |      source           type     score\n           <Rle>       <IRanges>  <Rle> |    <factor>       <factor> <numeric>\n    [1]        7 5526409-5563902      - | rtracklayer     gene              NA\n    [2]        7 5526409-5530601      - | rtracklayer     transcript        NA\n    [3]        7 5530542-5530601      - | rtracklayer     exon              NA\n    [4]        7 5529535-5529684      - | rtracklayer     exon              NA\n    [5]        7 5529535-5529657      - | rtracklayer     CDS               NA\n    ...      ...             ...    ... .         ...            ...       ...\n  [252]        7 5529535-5529657      - | rtracklayer CDS                   NA\n  [253]        7 5529655-5529657      - | rtracklayer start_codon           NA\n  [254]        7 5529282-5529400      - | rtracklayer exon                  NA\n  [255]        7 5529282-5529400      - | rtracklayer CDS                   NA\n  [256]        7 5529658-5529663      - | rtracklayer five_prime_utr        NA\n            phase         gene_id   gene_name   transcript_id\n        <integer>     <character> <character>     <character>\n    [1]      <NA> ENSG00000075624        ACTB            <NA>\n    [2]      <NA> ENSG00000075624        ACTB ENST00000674681\n    [3]      <NA> ENSG00000075624        ACTB ENST00000674681\n    [4]      <NA> ENSG00000075624        ACTB ENST00000674681\n    [5]      <NA> ENSG00000075624        ACTB ENST00000674681\n    ...       ...             ...         ...             ...\n  [252]      <NA> ENSG00000075624        ACTB ENST00000414620\n  [253]      <NA> ENSG00000075624        ACTB ENST00000414620\n  [254]      <NA> ENSG00000075624        ACTB ENST00000414620\n  [255]      <NA> ENSG00000075624        ACTB ENST00000414620\n  [256]      <NA> ENSG00000075624        ACTB ENST00000414620\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n```\n:::\n:::\n\n\nLike the `subset()` method, the `subsetByOverlaps()` method returns a new\n`GRanges` object.\nWe can visually compare the information printed in the object\n(256 ranges in the new subsetted object, relative to 267 ranges in the original\nobject), or we can programmatically compare the length of the two objects\nto check whether the new `GRanges` object is any smaller than the original\n`GRanges` object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(actb_in_region) - length(actb_gtf_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -11\n```\n:::\n:::\n\n\nIn the example above, we learn that the new `GRanges` object has 11 records less\nthan the original `GRanges` object.\n\n\n\n## Working with quantitative data: the **`SummarizedExperiment`** package\n\nThe figure below represents the anatomy of the SummarizedExperiment class.\n\n![](summarizedExperiment.svg){fig-align=\"center\"}\n\n\nObjects of the class `SummarizedExperiment` contain :\n\n- **One (or more) assay(s)** containing the quantitative omics data\n  (expression data), stored as a matrix-like object. Features (genes,\n  transcripts, proteins, ...) are defined along the rows, and samples\n  along the columns.\n\n- A **sample metadata** slot containing sample co-variates, stored as a\n  data frame. Rows from this table represent samples (rows match exactly the\n  columns of the expression data).\n\n- A **feature metadata** slot containing feature co-variates, stored as\n  a data frame. The rows of this data frame match exactly the rows of the\n  expression data.\n\nThe coordinated nature of the `SummarizedExperiment` guarantees that\nduring data manipulation, the dimensions of the different slots will\nalways match (i.e the columns in the expression data and then rows in\nthe sample metadata, as well as the rows in the expression data and\nfeature metadata) during data manipulation. For example, if we had to\nexclude one sample from the assay, it would be automatically removed\nfrom the sample metadata in the same operation.\n\nThe metadata slots can grow additional co-variates\n(columns) without affecting the other structures.\n\n### Creating a `SummarizedExperiment` object\n\nIn order to create a `SummarizedExperiment`, we will create the\nindividual components, i.e the count matrix, the sample and gene\nmetadata from csv files. These are typically how RNA-Seq data are\nprovided (after raw data have been processed).\n\n- **An expression matrix**: we load the count matrix, specifying that\n  the first columns contains row/gene names, and convert the\n  `data.frame` to a `matrix`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read count matrix\ncount_matrix <- read.csv(here(\"data\", \"count_matrix.csv\"), row.names = 1) |>\n    as.matrix()\n\n# Inspect data\ncount_matrix[1:5, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        GSM2545336 GSM2545337 GSM2545338 GSM2545339 GSM2545340 GSM2545341\nAsl           1170        361        400        586        626        988\nApod         36194      10347       9173      10620      13021      29594\nCyp2d22       4060       1616       1603       1901       2171       3349\nKlk6           287        629        641        578        448        195\nFcrls           85        233        244        237        180         38\n        GSM2545342 GSM2545343 GSM2545344 GSM2545345 GSM2545346 GSM2545347\nAsl            836        535        586        597        938       1035\nApod         24959      13668      13230      15868      27769      34301\nCyp2d22       3122       2008       2254       2277       2985       3452\nKlk6           186       1101        537        567        327        233\nFcrls           68        375        199        177         89         67\n        GSM2545348 GSM2545349 GSM2545350 GSM2545351 GSM2545352 GSM2545353\nAsl            494        481        666        937        803        541\nApod         11258      11812      15816      29242      20415      13682\nCyp2d22       1883       2014       2417       3678       2920       2216\nKlk6           742        881        828        250        798        710\nFcrls          300        233        231         81        303        285\n        GSM2545354 GSM2545362 GSM2545363 GSM2545380\nAsl            473        748        576       1192\nApod         11088      15916      11166      38148\nCyp2d22       1821       2842       2011       4019\nKlk6           894        501        598        259\nFcrls          248        179        184         68\n```\n:::\n\n```{.r .cell-code}\ndim(count_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1474   22\n```\n:::\n:::\n\n\n- **A table describing the samples**, often referred to as sample metadata.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read sample metadata\nsample_metadata <- read.csv(here(\"data\", \"sample_metadata.csv\"))\n\n# Inspect data\nsample_metadata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       sample     organism age    sex   infection  strain time     tissue mouse\n1  GSM2545336 Mus musculus   8 Female  InfluenzaA C57BL/6    8 Cerebellum    14\n2  GSM2545337 Mus musculus   8 Female NonInfected C57BL/6    0 Cerebellum     9\n3  GSM2545338 Mus musculus   8 Female NonInfected C57BL/6    0 Cerebellum    10\n4  GSM2545339 Mus musculus   8 Female  InfluenzaA C57BL/6    4 Cerebellum    15\n5  GSM2545340 Mus musculus   8   Male  InfluenzaA C57BL/6    4 Cerebellum    18\n6  GSM2545341 Mus musculus   8   Male  InfluenzaA C57BL/6    8 Cerebellum     6\n7  GSM2545342 Mus musculus   8 Female  InfluenzaA C57BL/6    8 Cerebellum     5\n8  GSM2545343 Mus musculus   8   Male NonInfected C57BL/6    0 Cerebellum    11\n9  GSM2545344 Mus musculus   8 Female  InfluenzaA C57BL/6    4 Cerebellum    22\n10 GSM2545345 Mus musculus   8   Male  InfluenzaA C57BL/6    4 Cerebellum    13\n11 GSM2545346 Mus musculus   8   Male  InfluenzaA C57BL/6    8 Cerebellum    23\n12 GSM2545347 Mus musculus   8   Male  InfluenzaA C57BL/6    8 Cerebellum    24\n13 GSM2545348 Mus musculus   8 Female NonInfected C57BL/6    0 Cerebellum     8\n14 GSM2545349 Mus musculus   8   Male NonInfected C57BL/6    0 Cerebellum     7\n15 GSM2545350 Mus musculus   8   Male  InfluenzaA C57BL/6    4 Cerebellum     1\n16 GSM2545351 Mus musculus   8 Female  InfluenzaA C57BL/6    8 Cerebellum    16\n17 GSM2545352 Mus musculus   8 Female  InfluenzaA C57BL/6    4 Cerebellum    21\n18 GSM2545353 Mus musculus   8 Female NonInfected C57BL/6    0 Cerebellum     4\n19 GSM2545354 Mus musculus   8   Male NonInfected C57BL/6    0 Cerebellum     2\n20 GSM2545362 Mus musculus   8 Female  InfluenzaA C57BL/6    4 Cerebellum    20\n21 GSM2545363 Mus musculus   8   Male  InfluenzaA C57BL/6    4 Cerebellum    12\n22 GSM2545380 Mus musculus   8 Female  InfluenzaA C57BL/6    8 Cerebellum    19\n```\n:::\n\n```{.r .cell-code}\ndim(sample_metadata)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 22  9\n```\n:::\n:::\n\n\n- **A table describing the genes**, often referred to as gene metadata.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read gene metadata\ngene_metadata <- read.csv(here(\"data\", \"gene_metadata.csv\"))\n\n# Inspect data\ngene_metadata[1:10, 1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      gene ENTREZID\n1      Asl   109900\n2     Apod    11815\n3  Cyp2d22    56448\n4     Klk6    19144\n5    Fcrls    80891\n6   Slc2a4    20528\n7     Exd2    97827\n8     Gjc2   118454\n9     Plp1    18823\n10    Gnb4    14696\n                                                                         product\n1                                 argininosuccinate lyase, transcript variant X1\n2                                         apolipoprotein D, transcript variant 3\n3   cytochrome P450, family 2, subfamily d, polypeptide 22, transcript variant 2\n4                           kallikrein related-peptidase 6, transcript variant 2\n5                  Fc receptor-like S, scavenger receptor, transcript variant X1\n6            solute carrier family 2 (facilitated glucose transporter), member 4\n7                                          exonuclease 3'-5' domain containing 2\n8                            gap junction protein, gamma 2, transcript variant 1\n9                           proteolipid protein (myelin) 1, transcript variant 1\n10 guanine nucleotide binding protein (G protein), beta 4, transcript variant X2\n      ensembl_gene_id\n1  ENSMUSG00000025533\n2  ENSMUSG00000022548\n3  ENSMUSG00000061740\n4  ENSMUSG00000050063\n5  ENSMUSG00000015852\n6  ENSMUSG00000018566\n7  ENSMUSG00000032705\n8  ENSMUSG00000043448\n9  ENSMUSG00000031425\n10 ENSMUSG00000027669\n```\n:::\n\n```{.r .cell-code}\ndim(gene_metadata)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1474    9\n```\n:::\n:::\n\n\nWe will create a `SummarizedExperiment` from these tables:\n\n- The count matrix that will be used as the **assay**\n\n- The table describing the samples will be used as the **colData** slot\n\n- The table describing the genes will be used as the **rowData** slot\n\nTo do this we can put the different parts together using the\n`SummarizedExperiment` constructor:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create SummarizedExperiment object\nse <- SummarizedExperiment(\n    assays = list(counts = count_matrix),\n    colData = sample_metadata,\n    rowData = gene_metadata\n)\n\nse\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SummarizedExperiment \ndim: 1474 22 \nmetadata(0):\nassays(1): counts\nrownames(1474): Asl Apod ... Lmx1a Pbx1\nrowData names(9): gene ENTREZID ... phenotype_description\n  hsapiens_homolog_associated_gene_name\ncolnames(22): GSM2545336 GSM2545337 ... GSM2545363 GSM2545380\ncolData names(9): sample organism ... tissue mouse\n```\n:::\n:::\n\n\nUsing this data structure, we can access the expression matrix with\nthe `assay()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(assay(se))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        GSM2545336 GSM2545337 GSM2545338 GSM2545339 GSM2545340 GSM2545341\nAsl           1170        361        400        586        626        988\nApod         36194      10347       9173      10620      13021      29594\nCyp2d22       4060       1616       1603       1901       2171       3349\nKlk6           287        629        641        578        448        195\nFcrls           85        233        244        237        180         38\nSlc2a4         782        231        248        265        313        786\n        GSM2545342 GSM2545343 GSM2545344 GSM2545345 GSM2545346 GSM2545347\nAsl            836        535        586        597        938       1035\nApod         24959      13668      13230      15868      27769      34301\nCyp2d22       3122       2008       2254       2277       2985       3452\nKlk6           186       1101        537        567        327        233\nFcrls           68        375        199        177         89         67\nSlc2a4         528        249        266        357        654        693\n        GSM2545348 GSM2545349 GSM2545350 GSM2545351 GSM2545352 GSM2545353\nAsl            494        481        666        937        803        541\nApod         11258      11812      15816      29242      20415      13682\nCyp2d22       1883       2014       2417       3678       2920       2216\nKlk6           742        881        828        250        798        710\nFcrls          300        233        231         81        303        285\nSlc2a4         271        304        349        715        513        320\n        GSM2545354 GSM2545362 GSM2545363 GSM2545380\nAsl            473        748        576       1192\nApod         11088      15916      11166      38148\nCyp2d22       1821       2842       2011       4019\nKlk6           894        501        598        259\nFcrls          248        179        184         68\nSlc2a4         248        350        317        796\n```\n:::\n\n```{.r .cell-code}\ndim(assay(se))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1474   22\n```\n:::\n:::\n\n\nWe can access the sample metadata using the `colData()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolData(se)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 22 rows and 9 columns\n                sample     organism       age         sex   infection\n           <character>  <character> <integer> <character> <character>\nGSM2545336  GSM2545336 Mus musculus         8      Female  InfluenzaA\nGSM2545337  GSM2545337 Mus musculus         8      Female NonInfected\nGSM2545338  GSM2545338 Mus musculus         8      Female NonInfected\nGSM2545339  GSM2545339 Mus musculus         8      Female  InfluenzaA\nGSM2545340  GSM2545340 Mus musculus         8        Male  InfluenzaA\n...                ...          ...       ...         ...         ...\nGSM2545353  GSM2545353 Mus musculus         8      Female NonInfected\nGSM2545354  GSM2545354 Mus musculus         8        Male NonInfected\nGSM2545362  GSM2545362 Mus musculus         8      Female  InfluenzaA\nGSM2545363  GSM2545363 Mus musculus         8        Male  InfluenzaA\nGSM2545380  GSM2545380 Mus musculus         8      Female  InfluenzaA\n                strain      time      tissue     mouse\n           <character> <integer> <character> <integer>\nGSM2545336     C57BL/6         8  Cerebellum        14\nGSM2545337     C57BL/6         0  Cerebellum         9\nGSM2545338     C57BL/6         0  Cerebellum        10\nGSM2545339     C57BL/6         4  Cerebellum        15\nGSM2545340     C57BL/6         4  Cerebellum        18\n...                ...       ...         ...       ...\nGSM2545353     C57BL/6         0  Cerebellum         4\nGSM2545354     C57BL/6         0  Cerebellum         2\nGSM2545362     C57BL/6         4  Cerebellum        20\nGSM2545363     C57BL/6         4  Cerebellum        12\nGSM2545380     C57BL/6         8  Cerebellum        19\n```\n:::\n\n```{.r .cell-code}\ndim(colData(se))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 22  9\n```\n:::\n:::\n\n\nWe can also access the feature metadata using the `rowData()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(rowData(se))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 6 rows and 9 columns\n               gene  ENTREZID                product    ensembl_gene_id\n        <character> <integer>            <character>        <character>\nAsl             Asl    109900 argininosuccinate ly.. ENSMUSG00000025533\nApod           Apod     11815 apolipoprotein D, tr.. ENSMUSG00000022548\nCyp2d22     Cyp2d22     56448 cytochrome P450, fam.. ENSMUSG00000061740\nKlk6           Klk6     19144 kallikrein related-p.. ENSMUSG00000050063\nFcrls         Fcrls     80891 Fc receptor-like S, .. ENSMUSG00000015852\nSlc2a4       Slc2a4     20528 solute carrier famil.. ENSMUSG00000018566\n        external_synonym chromosome_name   gene_biotype  phenotype_description\n             <character>     <character>    <character>            <character>\nAsl        2510006M18Rik               5 protein_coding abnormal circulating..\nApod                  NA              16 protein_coding abnormal lipid homeo..\nCyp2d22             2D22              15 protein_coding abnormal skin morpho..\nKlk6                Bssp               7 protein_coding abnormal cytokine le..\nFcrls      2810439C17Rik               3 protein_coding decreased CD8-positi..\nSlc2a4            Glut-4              11 protein_coding abnormal circulating..\n        hsapiens_homolog_associated_gene_name\n                                  <character>\nAsl                                       ASL\nApod                                     APOD\nCyp2d22                                CYP2D6\nKlk6                                     KLK6\nFcrls                                   FCRL2\nSlc2a4                                 SLC2A4\n```\n:::\n\n```{.r .cell-code}\ndim(rowData(se))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1474    9\n```\n:::\n:::\n\n\n### Subsetting a `SummarizedExperiment`\n\n`SummarizedExperiment` objects can be subset just like with data frames, with\nnumerics or with characters of logicals.\n\nBelow, we create a new instance of class SummarizedExperiment that\ncontains only the 5 first features for the 3 first samples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nse1 <- se[1:5, 1:3]\nse1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SummarizedExperiment \ndim: 5 3 \nmetadata(0):\nassays(1): counts\nrownames(5): Asl Apod Cyp2d22 Klk6 Fcrls\nrowData names(9): gene ENTREZID ... phenotype_description\n  hsapiens_homolog_associated_gene_name\ncolnames(3): GSM2545336 GSM2545337 GSM2545338\ncolData names(9): sample organism ... tissue mouse\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolData(se1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 3 rows and 9 columns\n                sample     organism       age         sex   infection\n           <character>  <character> <integer> <character> <character>\nGSM2545336  GSM2545336 Mus musculus         8      Female  InfluenzaA\nGSM2545337  GSM2545337 Mus musculus         8      Female NonInfected\nGSM2545338  GSM2545338 Mus musculus         8      Female NonInfected\n                strain      time      tissue     mouse\n           <character> <integer> <character> <integer>\nGSM2545336     C57BL/6         8  Cerebellum        14\nGSM2545337     C57BL/6         0  Cerebellum         9\nGSM2545338     C57BL/6         0  Cerebellum        10\n```\n:::\n\n```{.r .cell-code}\nrowData(se1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 5 rows and 9 columns\n               gene  ENTREZID                product    ensembl_gene_id\n        <character> <integer>            <character>        <character>\nAsl             Asl    109900 argininosuccinate ly.. ENSMUSG00000025533\nApod           Apod     11815 apolipoprotein D, tr.. ENSMUSG00000022548\nCyp2d22     Cyp2d22     56448 cytochrome P450, fam.. ENSMUSG00000061740\nKlk6           Klk6     19144 kallikrein related-p.. ENSMUSG00000050063\nFcrls         Fcrls     80891 Fc receptor-like S, .. ENSMUSG00000015852\n        external_synonym chromosome_name   gene_biotype  phenotype_description\n             <character>     <character>    <character>            <character>\nAsl        2510006M18Rik               5 protein_coding abnormal circulating..\nApod                  NA              16 protein_coding abnormal lipid homeo..\nCyp2d22             2D22              15 protein_coding abnormal skin morpho..\nKlk6                Bssp               7 protein_coding abnormal cytokine le..\nFcrls      2810439C17Rik               3 protein_coding decreased CD8-positi..\n        hsapiens_homolog_associated_gene_name\n                                  <character>\nAsl                                       ASL\nApod                                     APOD\nCyp2d22                                CYP2D6\nKlk6                                     KLK6\nFcrls                                   FCRL2\n```\n:::\n:::\n\n\nWe can also use the `colData()` function to subset on something from\nthe sample metadata or the `rowData()` to subset on something from the\nfeature metadata.  For example, here we keep only miRNAs and the non\ninfected samples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset object\nse1 <- se[rowData(se)$gene_biotype == \"miRNA\",\n          colData(se)$infection == \"NonInfected\"]\nse1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SummarizedExperiment \ndim: 7 7 \nmetadata(0):\nassays(1): counts\nrownames(7): Mir1901 Mir378a ... Mir128-1 Mir7682\nrowData names(9): gene ENTREZID ... phenotype_description\n  hsapiens_homolog_associated_gene_name\ncolnames(7): GSM2545337 GSM2545338 ... GSM2545353 GSM2545354\ncolData names(9): sample organism ... tissue mouse\n```\n:::\n\n```{.r .cell-code}\nassay(se1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         GSM2545337 GSM2545338 GSM2545343 GSM2545348 GSM2545349 GSM2545353\nMir1901          45         44         74         55         68         33\nMir378a          11          7          9          4         12          4\nMir133b           4          6          5          4          6          7\nMir30c-2         10          6         16         12          8         17\nMir149            1          2          0          0          0          0\nMir128-1          4          1          2          2          1          2\nMir7682           2          0          4          1          3          5\n         GSM2545354\nMir1901          60\nMir378a           8\nMir133b           3\nMir30c-2         15\nMir149            2\nMir128-1          1\nMir7682           5\n```\n:::\n\n```{.r .cell-code}\ncolData(se1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 7 rows and 9 columns\n                sample     organism       age         sex   infection\n           <character>  <character> <integer> <character> <character>\nGSM2545337  GSM2545337 Mus musculus         8      Female NonInfected\nGSM2545338  GSM2545338 Mus musculus         8      Female NonInfected\nGSM2545343  GSM2545343 Mus musculus         8        Male NonInfected\nGSM2545348  GSM2545348 Mus musculus         8      Female NonInfected\nGSM2545349  GSM2545349 Mus musculus         8        Male NonInfected\nGSM2545353  GSM2545353 Mus musculus         8      Female NonInfected\nGSM2545354  GSM2545354 Mus musculus         8        Male NonInfected\n                strain      time      tissue     mouse\n           <character> <integer> <character> <integer>\nGSM2545337     C57BL/6         0  Cerebellum         9\nGSM2545338     C57BL/6         0  Cerebellum        10\nGSM2545343     C57BL/6         0  Cerebellum        11\nGSM2545348     C57BL/6         0  Cerebellum         8\nGSM2545349     C57BL/6         0  Cerebellum         7\nGSM2545353     C57BL/6         0  Cerebellum         4\nGSM2545354     C57BL/6         0  Cerebellum         2\n```\n:::\n\n```{.r .cell-code}\nrowData(se1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 7 rows and 9 columns\n                gene  ENTREZID        product    ensembl_gene_id\n         <character> <integer>    <character>        <character>\nMir1901      Mir1901 100316686  microRNA 1901 ENSMUSG00000084565\nMir378a      Mir378a    723889  microRNA 378a ENSMUSG00000105200\nMir133b      Mir133b    723817  microRNA 133b ENSMUSG00000065480\nMir30c-2    Mir30c-2    723964 microRNA 30c-2 ENSMUSG00000065567\nMir149        Mir149    387167   microRNA 149 ENSMUSG00000065470\nMir128-1    Mir128-1    387147 microRNA 128-1 ENSMUSG00000065520\nMir7682      Mir7682 102466847  microRNA 7682 ENSMUSG00000106406\n         external_synonym chromosome_name gene_biotype  phenotype_description\n              <character>     <character>  <character>            <character>\nMir1901          Mirn1901              18        miRNA                     NA\nMir378a           Mirn378              18        miRNA abnormal mitochondri..\nMir133b          mir 133b               1        miRNA no abnormal phenotyp..\nMir30c-2        mir 30c-2               1        miRNA                     NA\nMir149            Mirn149               1        miRNA increased circulatin..\nMir128-1          Mirn128               1        miRNA no abnormal phenotyp..\nMir7682      mmu-mir-7682               1        miRNA                     NA\n         hsapiens_homolog_associated_gene_name\n                                   <character>\nMir1901                                     NA\nMir378a                                MIR378A\nMir133b                                MIR133B\nMir30c-2                               MIR30C2\nMir149                                      NA\nMir128-1                              MIR128-1\nMir7682                                     NA\n```\n:::\n:::\n\n\n\n::: {.callout-tip}\n\n### Practice\n\n1. Extract the gene expression levels of the 3 first genes in samples\nat time 0 and at time 8.\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassay(se)[1:3, colData(se)$time != 4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        GSM2545336 GSM2545337 GSM2545338 GSM2545341 GSM2545342 GSM2545343\nAsl           1170        361        400        988        836        535\nApod         36194      10347       9173      29594      24959      13668\nCyp2d22       4060       1616       1603       3349       3122       2008\n        GSM2545346 GSM2545347 GSM2545348 GSM2545349 GSM2545351 GSM2545353\nAsl            938       1035        494        481        937        541\nApod         27769      34301      11258      11812      29242      13682\nCyp2d22       2985       3452       1883       2014       3678       2216\n        GSM2545354 GSM2545380\nAsl            473       1192\nApod         11088      38148\nCyp2d22       1821       4019\n```\n:::\n\n```{.r .cell-code}\n# Equivalent to\nassay(se)[1:3, colData(se)$time == 0 | colData(se)$time == 8]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        GSM2545336 GSM2545337 GSM2545338 GSM2545341 GSM2545342 GSM2545343\nAsl           1170        361        400        988        836        535\nApod         36194      10347       9173      29594      24959      13668\nCyp2d22       4060       1616       1603       3349       3122       2008\n        GSM2545346 GSM2545347 GSM2545348 GSM2545349 GSM2545351 GSM2545353\nAsl            938       1035        494        481        937        541\nApod         27769      34301      11258      11812      29242      13682\nCyp2d22       2985       3452       1883       2014       3678       2216\n        GSM2545354 GSM2545380\nAsl            473       1192\nApod         11088      38148\nCyp2d22       1821       4019\n```\n:::\n:::\n\n\n:::\n:::\n\n\n### Saving data\n\nExporting data to a spreadsheet, as we did in a previous lesson, has\nseveral limitations, such as those described in the first chapter\n(possible inconsistencies with `,` and `.` for decimal separators and\nlack of variable type definitions). Furthermore, exporting data to a\nspreadsheet is only relevant for rectangular data such as dataframes\nand matrices.\n\nA more general way to save data, that is specific to R and is\nguaranteed to work on any operating system, is to use the `saveRDS()`\nfunction. Saving objects like this will generate a binary\nrepresentation on disk (using the `rds` file extension here), which\ncan be loaded back into R using the `readRDS` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save R object as an RDS file\nsaveRDS(se, file = here(\"output\", \"se.rds\"))\nrm(se)\n\nse <- readRDS(here(\"output\", \"se.rds\"))\nhead(se)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SummarizedExperiment \ndim: 6 22 \nmetadata(0):\nassays(1): counts\nrownames(6): Asl Apod ... Fcrls Slc2a4\nrowData names(9): gene ENTREZID ... phenotype_description\n  hsapiens_homolog_associated_gene_name\ncolnames(22): GSM2545336 GSM2545337 ... GSM2545363 GSM2545380\ncolData names(9): sample organism ... tissue mouse\n```\n:::\n:::\n\n\nTo conclude, when it comes to saving data from R that will be loaded\nagain in R, saving and loading with `saveRDS` and `readRDS` is the\npreferred approach. If tabular data need to be shared with somebody\nthat is not using R, then exporting to a text-based spreadsheet is a\ngood alternative.\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}